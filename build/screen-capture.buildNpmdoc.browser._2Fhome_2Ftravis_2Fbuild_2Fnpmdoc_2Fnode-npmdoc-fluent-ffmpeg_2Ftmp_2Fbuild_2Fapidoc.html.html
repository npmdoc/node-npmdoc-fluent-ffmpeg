<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg#readme">fluent-ffmpeg (v2.1.0)</a>
</h1>
<h4>A fluent API to FFMPEG (http://www.ffmpeg.org)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg">module fluent-ffmpeg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.ffprobe">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>ffprobe
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.setFfmpegPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfmpegPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.setFfprobePath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfprobePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.setFlvtoolPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFlvtoolPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.super_">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>jsdoc_aliases</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.jsdoc_aliases">module fluent-ffmpeg.jsdoc_aliases</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.jsdoc_aliases.defineTags">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.jsdoc_aliases.</span>defineTags
            <span class="apidocSignatureSpan">(dict)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.jsdoc_aliases.</span>handlers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.utils">module fluent-ffmpeg.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.args">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>args
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.copy">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>copy
            <span class="apidocSignatureSpan">(source, dest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.extractCodecData">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractCodecData
            <span class="apidocSignatureSpan">(command, stderrLine, codecsObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.extractError">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractError
            <span class="apidocSignatureSpan">(stderr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.extractProgress">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractProgress
            <span class="apidocSignatureSpan">(command, stderrLine, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.linesRing">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>linesRing
            <span class="apidocSignatureSpan">(maxLines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.makeFilterStrings">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>makeFilterStrings
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.timemarkToSeconds">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>timemarkToSeconds
            <span class="apidocSignatureSpan">(timemark)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.which">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>which
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>isWindows</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>streamRegexp</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg" id="apidoc.module.fluent-ffmpeg">module fluent-ffmpeg</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableCodecs" id="apidoc.element.fluent-ffmpeg.availableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableCodecs = function (callback) {
  (new FfmpegCommand()).availableCodecs(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableFilters" id="apidoc.element.fluent-ffmpeg.availableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFilters = function (callback) {
  (new FfmpegCommand()).availableFilters(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableFormats" id="apidoc.element.fluent-ffmpeg.availableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFormats = function (callback) {
  (new FfmpegCommand()).availableFormats(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @private
   */
  proto._checkCapabilities = function(callback) {
    var self = this;
    async.waterfall([
      // Get available formats
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableFormats</span>(cb);
      },

      // Check whether specified formats are available
      function(formats, cb) {
var unavailable;

// Output format(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.ffprobe" id="apidoc.element.fluent-ffmpeg.ffprobe">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>ffprobe
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ffprobe = function (file) {
  var instance = new FfmpegCommand(file);
  instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


### Reading video metadata

You can read metadata from any valid ffmpeg input file with the modules `ffprobe` method.

```js
ffmpeg.<span class="apidocCodeKeywordSpan">ffprobe</span>('/path/to/file.avi', function(err, metadata) {
    console.dir(metadata);
});
```

You may also call the ffprobe method on an FfmpegCommand to probe one of its input.  You may pass a 0-based input number as a first
 argument to specify which input to read metadata from, otherwise the method will probe the last added input.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableCodecs" id="apidoc.element.fluent-ffmpeg.getAvailableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableCodecs = function (callback) {
  (new FfmpegCommand()).availableCodecs(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Ffmpeg = require('fluent-ffmpeg');

Ffmpeg.getAvailableFormats(function(err, formats) {
console.log('Available formats:');
console.dir(formats);
});

Ffmpeg.<span class="apidocCodeKeywordSpan">getAvailableCodecs</span>(function(err, codecs) {
console.log('Available codecs:');
console.dir(codecs);
});

Ffmpeg.getAvailableEncoders(function(err, encoders) {
console.log('Available encoders:');
console.dir(encoders);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableFilters" id="apidoc.element.fluent-ffmpeg.getAvailableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFilters = function (callback) {
  (new FfmpegCommand()).availableFilters(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

Ffmpeg.getAvailableEncoders(function(err, encoders) {
console.log('Available encoders:');
console.dir(encoders);
});

Ffmpeg.<span class="apidocCodeKeywordSpan">getAvailableFilters</span>(function(err, filters) {
console.log("Available filters:");
console.dir(filters);
});

// Those methods can also be called on commands
new Ffmpeg({ source: '/path/to/file.avi' })
.getAvailableCodecs(...);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableFormats" id="apidoc.element.fluent-ffmpeg.getAvailableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFormats = function (callback) {
  (new FfmpegCommand()).availableFormats(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

fluent-ffmpeg enables you to query your installed ffmpeg version for supported formats, codecs, encoders and filters.

```js

var Ffmpeg = require('fluent-ffmpeg');

Ffmpeg.<span class="apidocCodeKeywordSpan">getAvailableFormats</span>(function(err, formats) {
console.log('Available formats:');
console.dir(formats);
});

Ffmpeg.getAvailableCodecs(function(err, codecs) {
console.log('Available codecs:');
console.dir(codecs);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.setFfmpegPath" id="apidoc.element.fluent-ffmpeg.setFfmpegPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfmpegPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfmpegPath = function (path) {
  (new FfmpegCommand()).setFfmpegPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

If you intend to encode FLV videos, you must have either flvtool2 or flvmeta installed and in your `PATH` or fluent-ffmpeg won&amp;#
x27;t be able to produce streamable output files.  If you set either the `FLVTOOL2_PATH` or `FLVMETA_PATH`, fluent-ffmpeg will try
 to use it instead of searching in the `PATH`.

#### Setting binary paths manually

Alternatively, you may set the ffmpeg, ffprobe and flvtool2/flvmeta binary paths manually by using the following API commands:

* **Ffmpeg.<span class="apidocCodeKeywordSpan">setFfmpegPath</span>(path)** Argument `path` is a string with the full path to the
 ffmpeg binary.
* **Ffmpeg.setFfprobePath(path)** Argument `path` is a string with the full path to the ffprobe binary.
* **Ffmpeg.setFlvtoolPath(path)** Argument `path` is a string with the full path to the flvtool2 or flvmeta binary.


### Creating an FFmpeg command

The fluent-ffmpeg module returns a constructor that you can use to instanciate FFmpeg commands.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.setFfprobePath" id="apidoc.element.fluent-ffmpeg.setFfprobePath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfprobePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfprobePath = function (path) {
  (new FfmpegCommand()).setFfprobePath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you intend to encode FLV videos, you must have either flvtool2 or flvmeta installed and in your `PATH` or fluent-ffmpeg won&amp;#
x27;t be able to produce streamable output files.  If you set either the `FLVTOOL2_PATH` or `FLVMETA_PATH`, fluent-ffmpeg will try
 to use it instead of searching in the `PATH`.

#### Setting binary paths manually

Alternatively, you may set the ffmpeg, ffprobe and flvtool2/flvmeta binary paths manually by using the following API commands:

* **Ffmpeg.setFfmpegPath(path)** Argument `path` is a string with the full path to the ffmpeg binary.
* **Ffmpeg.<span class="apidocCodeKeywordSpan">setFfprobePath</span>(path)** Argument `path` is a string with the full path to the
 ffprobe binary.
* **Ffmpeg.setFlvtoolPath(path)** Argument `path` is a string with the full path to the flvtool2 or flvmeta binary.


### Creating an FFmpeg command

The fluent-ffmpeg module returns a constructor that you can use to instanciate FFmpeg commands.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.setFlvtoolPath" id="apidoc.element.fluent-ffmpeg.setFlvtoolPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFlvtoolPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFlvtoolPath = function (path) {
  (new FfmpegCommand()).setFlvtoolPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Setting binary paths manually

Alternatively, you may set the ffmpeg, ffprobe and flvtool2/flvmeta binary paths manually by using the following API commands:

* **Ffmpeg.setFfmpegPath(path)** Argument `path` is a string with the full path to the ffmpeg binary.
* **Ffmpeg.setFfprobePath(path)** Argument `path` is a string with the full path to the ffprobe binary.
* **Ffmpeg.<span class="apidocCodeKeywordSpan">setFlvtoolPath</span>(path)** Argument `path` is a string with the full path to the
 flvtool2 or flvmeta binary.


### Creating an FFmpeg command

The fluent-ffmpeg module returns a constructor that you can use to instanciate FFmpeg commands.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.super_" id="apidoc.element.fluent-ffmpeg.super_">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.jsdoc_aliases" id="apidoc.module.fluent-ffmpeg.jsdoc_aliases">module fluent-ffmpeg.jsdoc_aliases</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.jsdoc_aliases.defineTags" id="apidoc.element.fluent-ffmpeg.jsdoc_aliases.defineTags">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.jsdoc_aliases.</span>defineTags
        <span class="apidocSignatureSpan">(dict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineTags = function (dict) {
	dict.defineTag('aliases', {
		onTagged: function(doclet, tag) {
			doclet.aliases = tag.text.split(',');
		}
	});

	dict.defineTag('category', {
		onTagged: function(doclet, tag) {
			doclet.category = tag.text;
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.utils" id="apidoc.module.fluent-ffmpeg.utils">module fluent-ffmpeg.utils</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.args" id="apidoc.element.fluent-ffmpeg.utils.args">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>args
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">args = function () {
  var list = [];

  // Append argument(s) to the list
  var argfunc = function() {
    if (arguments.length === 1 &amp;&amp; Array.isArray(arguments[0])) {
      list = list.concat(arguments[0]);
    } else {
      list = list.concat([].slice.call(arguments));
    }
  };

  // Clear argument list
  argfunc.clear = function() {
    list = [];
  };

  // Return argument list
  argfunc.get = function() {
    return list;
  };

  // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it
  argfunc.find = function(arg, count) {
    var index = list.indexOf(arg);
    if (index !== -1) {
      return list.slice(index + 1, index + 1 + (count || 0));
    }
  };

  // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it
  argfunc.remove = function(arg, count) {
    var index = list.indexOf(arg);
    if (index !== -1) {
      list.splice(index, (count || 0) + 1);
    }
  };

  // Clone argument list
  argfunc.clone = function() {
    var cloned = utils.args();
    cloned(list);
    return cloned;
  };

  return argfunc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (index !== -1) {
      list.splice(index, (count || 0) + 1);
    }
  };

  // Clone argument list
  argfunc.clone = function() {
    var cloned = utils.<span class="apidocCodeKeywordSpan">args</span>();
    cloned(list);
    return cloned;
  };

  return argfunc;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.copy" id="apidoc.element.fluent-ffmpeg.utils.copy">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>copy
        <span class="apidocSignatureSpan">(source, dest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (source, dest) {
  Object.keys(source).forEach(function(key) {
    dest[key] = source[key];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          encoders = encoders ? encoders[1].trim().split(' ') : [];

          var decoders = codecData.description.match(ffDecodersRegexp);
          decoders = decoders ? decoders[1].trim().split(' ') : [];

          if (encoders.length || decoders.length) {
var coderData = {};
utils.<span class="apidocCodeKeywordSpan">copy</span>(codecData, coderData);
delete coderData.canEncode;
delete coderData.canDecode;

encoders.forEach(function(name) {
  data[name] = {};
  utils.copy(coderData, data[name]);
  data[name].canEncode = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.extractCodecData" id="apidoc.element.fluent-ffmpeg.utils.extractCodecData">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractCodecData
        <span class="apidocSignatureSpan">(command, stderrLine, codecsObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractCodecData = function (command, stderrLine, codecsObject) {
  var inputPattern = /Input #[0-9]+, ([^ ]+),/;
  var durPattern = /Duration\: ([^,]+)/;
  var audioPattern = /Audio\: (.*)/;
  var videoPattern = /Video\: (.*)/;

  if (!('inputStack' in codecsObject)) {
    codecsObject.inputStack = [];
    codecsObject.inputIndex = -1;
    codecsObject.inInput = false;
  }

  var inputStack = codecsObject.inputStack;
  var inputIndex = codecsObject.inputIndex;
  var inInput = codecsObject.inInput;

  var format, dur, audio, video;

  if (format = stderrLine.match(inputPattern)) {
    inInput = codecsObject.inInput = true;
    inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;

    inputStack[inputIndex] = { format: format[1], audio: '', video: '', duration: '' };
  } else if (inInput &amp;&amp; (dur = stderrLine.match(durPattern))) {
    inputStack[inputIndex].duration = dur[1];
  } else if (inInput &amp;&amp; (audio = stderrLine.match(audioPattern))) {
    audio = audio[1].split(', ');
    inputStack[inputIndex].audio = audio[0];
    inputStack[inputIndex].audio_details = audio;
  } else if (inInput &amp;&amp; (video = stderrLine.match(videoPattern))) {
    video = video[1].split(', ');
    inputStack[inputIndex].video = video[0];
    inputStack[inputIndex].video_details = video;
  } else if (/Output #\d+/.test(stderrLine)) {
    inInput = codecsObject.inInput = false;
  } else if (/Stream mapping:|Press (\[q\]|ctrl-c) to stop/.test(stderrLine)) {
    command.emit.apply(command, ['codecData'].concat(inputStack));
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 'codecData' event
if (self.listeners('codecData').length) {
  var codecDataSent = false;
  var codecObject = {};

  stderrRing.callback(function(line) {
    if (!codecDataSent)
      codecDataSent = utils.<span class="apidocCodeKeywordSpan">extractCodecData</span>(self, line, codecObject);
  });
}

// 'progress' event
if (self.listeners('progress').length) {
  var duration = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.extractError" id="apidoc.element.fluent-ffmpeg.utils.extractError">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractError
        <span class="apidocSignatureSpan">(stderr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractError = function (stderr) {
  // Only return the last stderr lines that don't start with a space or a square bracket
  return stderr.split(nlRegexp).reduce(function(messages, message) {
    if (message.charAt(0) === ' ' || message.charAt(0) === '[') {
      return [];
    } else {
      messages.push(message);
      return messages;
    }
  }, []).join('\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        function endCB(err, stdoutRing, stderrRing) {
delete self.ffmpegProc;

if (err) {
  if (err.message.match(/ffmpeg exited with code/)) {
    // Add ffmpeg error message
    err.message += ': ' + utils.<span class="apidocCodeKeywordSpan">extractError</span>(stderrRing.get());
  }

  emitEnd(err, stdoutRing.get(), stderrRing.get());
} else {
  // Find out which outputs need flv metadata
  var flvmeta = self._outputs.filter(function(output) {
    return output.flags.flvmeta;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.extractProgress" id="apidoc.element.fluent-ffmpeg.utils.extractProgress">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractProgress
        <span class="apidocSignatureSpan">(command, stderrLine, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractProgress = function (command, stderrLine, duration) {
  var progress = parseProgressLine(stderrLine);

  if (progress) {
    // build progress report object
    var ret = {
      frames: parseInt(progress.frame, 10),
      currentFps: parseInt(progress.fps, 10),
      currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,
      targetSize: parseInt(progress.size, 10),
      timemark: progress.time
    };

    // calculate percent progress using duration
    if (duration &amp;&amp; duration &gt; 0) {
      ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;
    }

    command.emit('progress', ret);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var duration = 0;

      if (self._ffprobeData &amp;&amp; self._ffprobeData.format &amp;&amp; self._ffprobeData.format.duration) {
        duration = Number(self._ffprobeData.format.duration);
      }

      stderrRing.callback(function(line) {
        utils.<span class="apidocCodeKeywordSpan">extractProgress</span>(self, line, duration);
      });
    }
  }
},

function endCB(err, stdoutRing, stderrRing) {
  delete self.ffmpegProc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.linesRing" id="apidoc.element.fluent-ffmpeg.utils.linesRing">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>linesRing
        <span class="apidocSignatureSpan">(maxLines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linesRing = function (maxLines) {
  var cbs = [];
  var lines = [];
  var current = null;
  var closed = false
  var max = maxLines - 1;

  function emit(line) {
    cbs.forEach(function(cb) { cb(line); });
  }

  return {
    callback: function(cb) {
      lines.forEach(function(l) { cb(l); });
      cbs.push(cb);
    },

    append: function(str) {
      if (closed) return;
      if (str instanceof Buffer) str = '' + str;
      if (!str || str.length === 0) return;

      var newLines = str.split(nlRegexp);

      if (newLines.length === 1) {
        if (current !== null) {
          current = current + newLines.shift();
        } else {
          current = newLines.shift();
        }
      } else {
        if (current !== null) {
          current = current + newLines.shift();
          emit(current);
          lines.push(current);
        }

        current = newLines.pop();

        newLines.forEach(function(l) {
          emit(l);
          lines.push(l);
        });

        if (max &gt; -1 &amp;&amp; lines.length &gt; max) {
          lines.splice(0, lines.length - max);
        }
      }
    },

    get: function() {
      if (current !== null) {
        return lines.concat([current]).join('\n');
      } else {
        return lines.join('\n');
      }
    },

    close: function() {
      if (closed) return;

      if (current !== null) {
        emit(current);
        lines.push(current);

        if (max &gt; -1 &amp;&amp; lines.length &gt; max) {
          lines.shift();
        }

        current = null;
      }

      closed = true;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Apply niceness
if (options.niceness &amp;&amp; options.niceness !== 0 &amp;&amp; !utils.isWindows) {
  args.unshift('-n', options.niceness, command);
  command = 'nice';
}

var stdoutRing = utils.<span class="apidocCodeKeywordSpan">linesRing</span>(maxLines);
var stdoutClosed = false;

var stderrRing = utils.linesRing(maxLines);
var stderrClosed = false;

// Spawn process
var ffmpegProc = spawn(command, args, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.makeFilterStrings" id="apidoc.element.fluent-ffmpeg.utils.makeFilterStrings">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>makeFilterStrings
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFilterStrings = function (filters) {
  return filters.map(function(filterSpec) {
    if (typeof filterSpec === 'string') {
      return filterSpec;
    }

    var filterString = '';

    // Filter string format is:
    // [input1][input2]...filter[output1][output2]...
    // The 'filter' part can optionaly have arguments:
    //   filter=arg1:arg2:arg3
    //   filter=arg1=v1:arg2=v2:arg3=v3

    // Add inputs
    if (Array.isArray(filterSpec.inputs)) {
      filterString += filterSpec.inputs.map(function(streamSpec) {
        return streamSpec.replace(streamRegexp, '[$1]');
      }).join('');
    } else if (typeof filterSpec.inputs === 'string') {
      filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');
    }

    // Add filter
    filterString += filterSpec.filter;

    // Add options
    if (filterSpec.options) {
      if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {
        // Option string
        filterString += '=' + filterSpec.options;
      } else if (Array.isArray(filterSpec.options)) {
        // Option array (unnamed options)
        filterString += '=' + filterSpec.options.map(function(option) {
          if (typeof option === 'string' &amp;&amp; option.match(filterEscapeRegexp)) {
            return '\'' + option + '\'';
          } else {
            return option;
          }
        }).join(':');
      } else if (Object.keys(filterSpec.options).length) {
        // Option object (named options)
        filterString += '=' + Object.keys(filterSpec.options).map(function(option) {
          var value = filterSpec.options[option];

          if (typeof value === 'string' &amp;&amp; value.match(filterEscapeRegexp)) {
            value = '\'' + value + '\'';
          }

          return option + '=' + value;
        }).join(':');
      }
    }

    // Add outputs
    if (Array.isArray(filterSpec.outputs)) {
      filterString += filterSpec.outputs.map(function(streamSpec) {
        return streamSpec.replace(streamRegexp, '[$1]');
      }).join('');
    } else if (typeof filterSpec.outputs === 'string') {
      filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');
    }

    return filterString;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fileOutput ? ['-y'] : [],

        // Complex filters
        complexFilters,

        // Outputs, filters and output options
        this._outputs.reduce(function(args, output) {
var sizeFilters = utils.<span class="apidocCodeKeywordSpan">makeFilterStrings</span>(output.sizeFilters.get());
var audioFilters = output.audioFilters.get();
var videoFilters = output.videoFilters.get().concat(sizeFilters);
var outputArg;

if (!output.target) {
  outputArg = [];
} else if (typeof output.target === 'string') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.timemarkToSeconds" id="apidoc.element.fluent-ffmpeg.utils.timemarkToSeconds">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>timemarkToSeconds
        <span class="apidocSignatureSpan">(timemark)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timemarkToSeconds = function (timemark) {
  if (typeof timemark === 'number') {
    return timemark;
  }

  if (timemark.indexOf(':') === -1 &amp;&amp; timemark.indexOf('.') &gt;= 0) {
    return Number(timemark);
  }

  var parts = timemark.split(':');

  // add seconds
  var secs = Number(parts.pop());

  if (parts.length) {
    // add minutes
    secs += Number(parts.pop()) * 60;
  }

  if (parts.length) {
    // add hours
    secs += Number(parts.pop()) * 3600;
  }

  return secs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    next();
  }
},

// Turn all timemarks into numbers and sort them
function normalizeTimemarks(next) {
  config.timemarks = config.timemarks.map(function(mark) {
    return utils.<span class="apidocCodeKeywordSpan">timemarkToSeconds</span>(mark);
  }).sort(function(a, b) { return a - b; });

  next();
},

// Add '_%i' to pattern when requesting multiple screenshots and no variable token is present
function fixPattern(next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.which" id="apidoc.element.fluent-ffmpeg.utils.which">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>which
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">which = function (name, callback) {
  if (name in whichCache) {
    return callback(null, whichCache[name]);
  }

  which(name, function(err, result){
    if (err) {
      // Treat errors as not found
      return callback(null, whichCache[name] = '');
    }
    callback(null, whichCache[name] = result);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // Search in the PATH
  function(ffmpeg, cb) {
    if (ffmpeg.length) {
      return cb(null, ffmpeg);
    }

    utils.<span class="apidocCodeKeywordSpan">which</span>('ffmpeg', function(err, ffmpeg) {
      cb(err, ffmpeg);
    });
  }
], function(err, ffmpeg) {
  if (err) {
    callback(err);
  } else {
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>