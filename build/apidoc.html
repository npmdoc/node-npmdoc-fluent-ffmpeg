<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg#readme"

    >fluent-ffmpeg (v2.1.2)</a>
</h1>
<h4>A fluent API to FFMPEG (http://www.ffmpeg.org)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg">module fluent-ffmpeg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent-ffmpeg">
            function <span class="apidocSignatureSpan"></span>fluent-ffmpeg
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableEncoders">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableEncoders
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.availableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.ffprobe">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>ffprobe
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>fluent_ffmpeg
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableEncoders">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableEncoders
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.getAvailableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.setFfmpegPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfmpegPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.setFfprobePath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfprobePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.setFlvtoolPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFlvtoolPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.super_">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>divx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>flashvideo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>fluent_ffmpeg.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>jsdoc_aliases</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>podcast</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.divx">module fluent-ffmpeg.divx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.divx.load">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.divx.</span>load
            <span class="apidocSignatureSpan">(ffmpeg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.flashvideo">module fluent-ffmpeg.flashvideo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.flashvideo.load">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.flashvideo.</span>load
            <span class="apidocSignatureSpan">(ffmpeg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.fluent_ffmpeg">module fluent-ffmpeg.fluent_ffmpeg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.fluent_ffmpeg">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>fluent_ffmpeg
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableEncoders">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableEncoders
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.ffprobe">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>ffprobe
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableEncoders">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableEncoders
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFfmpegPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>setFfmpegPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFfprobePath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>setFfprobePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFlvtoolPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>setFlvtoolPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.super_">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.fluent_ffmpeg.prototype">module fluent-ffmpeg.fluent_ffmpeg.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPS">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>FPS
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPSInput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>FPSInput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPSOutput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>FPSOutput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._checkCapabilities">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_checkCapabilities
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._forgetPaths">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_forgetPaths
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getArguments">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getArguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFfmpegPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getFfmpegPath
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFfprobePath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getFfprobePath
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFlvtoolPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getFlvtoolPath
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._prepare">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_prepare
            <span class="apidocSignatureSpan">(callback, readMetadata)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._spawnFfmpeg">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_spawnFfmpeg
            <span class="apidocSignatureSpan">(args, options, processCB, endCB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addInput
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInputOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addInputOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInputOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addInputOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOutput
            <span class="apidocSignatureSpan">(target, pipeopts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutputOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOutputOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutputOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOutputOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutoPad">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutoPad
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutoPadding">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutoPadding
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutopad">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutopad
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutopadding">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutopadding
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.aspect">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>aspect
            <span class="apidocSignatureSpan">(aspect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.aspectRatio">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>aspectRatio
            <span class="apidocSignatureSpan">(aspect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioBitrate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioBitrate
            <span class="apidocSignatureSpan">(bitrate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioChannels">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioChannels
            <span class="apidocSignatureSpan">(channels)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioCodec">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioCodec
            <span class="apidocSignatureSpan">(codec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFilter">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioFilter
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioFilters
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFrequency">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioFrequency
            <span class="apidocSignatureSpan">(freq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioQuality">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioQuality
            <span class="apidocSignatureSpan">(quality)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.autoPad">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>autoPad
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.autopad">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>autopad
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableEncoders">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableEncoders
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.clone">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.complexFilter">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>complexFilter
            <span class="apidocSignatureSpan">(spec, map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.concat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>concat
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.concatenate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>concatenate
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.duration">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>duration
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.exec">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.execute">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>execute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.ffprobe">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>ffprobe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.filterGraph">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>filterGraph
            <span class="apidocSignatureSpan">(spec, map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.flvmeta">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>flvmeta
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.format">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>format
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fps">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fps
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fpsInput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fpsInput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fpsOutput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fpsOutput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.frames">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>frames
            <span class="apidocSignatureSpan">(frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fromFormat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fromFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableCodecs">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableCodecs
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableEncoders">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableEncoders
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableFilters
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableFormats">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableFormats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.input">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>input
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFPS">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputFPS
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFormat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFps">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputFps
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDAR">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepDAR
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDisplayAspect">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepDisplayAspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDisplayAspectRatio">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepDisplayAspectRatio
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepPixelAspect">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepPixelAspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.kill">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>kill
            <span class="apidocSignatureSpan">(signal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.loop">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>loop
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.map">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>map
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.mergeAdd">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>mergeAdd
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.mergeToFile">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>mergeToFile
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.native">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>native
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.nativeFramerate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>nativeFramerate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.noAudio">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>noAudio
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.noVideo">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>noVideo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.output">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>output
            <span class="apidocSignatureSpan">(target, pipeopts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFPS">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputFPS
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFormat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFps">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputFps
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.pipe">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>pipe
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.preset">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>preset
            <span class="apidocSignatureSpan">(preset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.renice">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>renice
            <span class="apidocSignatureSpan">(niceness)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.run">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>run
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.save">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>save
            <span class="apidocSignatureSpan">(output)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.saveToFile">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>saveToFile
            <span class="apidocSignatureSpan">(output)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.screenshot">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>screenshot
            <span class="apidocSignatureSpan">(config, folder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.screenshots">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>screenshots
            <span class="apidocSignatureSpan">(config, folder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seek">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>seek
            <span class="apidocSignatureSpan">(seek)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seekInput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>seekInput
            <span class="apidocSignatureSpan">(seek)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seekOutput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>seekOutput
            <span class="apidocSignatureSpan">(seek)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setAspect">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setAspect
            <span class="apidocSignatureSpan">(aspect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setAspectRatio">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setAspectRatio
            <span class="apidocSignatureSpan">(aspect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setDuration">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setDuration
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFfmpegPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setFfmpegPath
            <span class="apidocSignatureSpan">(ffmpegPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFfprobePath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setFfprobePath
            <span class="apidocSignatureSpan">(ffprobePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFlvtoolPath">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setFlvtoolPath
            <span class="apidocSignatureSpan">(flvtool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setSize">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setSize
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setStartTime">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setStartTime
            <span class="apidocSignatureSpan">(seek)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.size">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>size
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.stream">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>stream
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.takeFrames">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>takeFrames
            <span class="apidocSignatureSpan">(frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.takeScreenshots">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>takeScreenshots
            <span class="apidocSignatureSpan">(config, folder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.thumbnail">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>thumbnail
            <span class="apidocSignatureSpan">(config, folder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.thumbnails">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>thumbnails
            <span class="apidocSignatureSpan">(config, folder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.toFormat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>toFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.updateFlvMetadata">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>updateFlvMetadata
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.usingPreset">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>usingPreset
            <span class="apidocSignatureSpan">(preset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoBitrate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoBitrate
            <span class="apidocSignatureSpan">(bitrate, constant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoCodec">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoCodec
            <span class="apidocSignatureSpan">(codec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoFilter">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoFilter
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoFilters
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAspect">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAspect
            <span class="apidocSignatureSpan">(aspect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAspectRatio">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAspectRatio
            <span class="apidocSignatureSpan">(aspect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioBitrate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioBitrate
            <span class="apidocSignatureSpan">(bitrate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioChannels">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioChannels
            <span class="apidocSignatureSpan">(channels)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioCodec">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioCodec
            <span class="apidocSignatureSpan">(codec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFilter">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioFilter
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioFilters
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFrequency">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioFrequency
            <span class="apidocSignatureSpan">(freq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioQuality">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioQuality
            <span class="apidocSignatureSpan">(quality)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutoPad">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutoPad
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutoPadding">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutoPadding
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutopad">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutopad
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutopadding">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutopadding
            <span class="apidocSignatureSpan">(pad, color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withDuration">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withDuration
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPS">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFPS
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPSInput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFPSInput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPSOutput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFPSOutput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFps">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFps
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFpsInput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFpsInput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFpsOutput">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFpsOutput
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFrames">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFrames
            <span class="apidocSignatureSpan">(frames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFPS">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputFPS
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFormat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFps">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputFps
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNativeFramerate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withNativeFramerate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNoAudio">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withNoAudio
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNoVideo">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withNoVideo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFPS">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputFPS
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFormat">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFps">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputFps
            <span class="apidocSignatureSpan">(fps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputOption">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputOption
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputOptions">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withSize">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withSize
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoBitrate">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoBitrate
            <span class="apidocSignatureSpan">(bitrate, constant)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoCodec">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoCodec
            <span class="apidocSignatureSpan">(codec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoFilter">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoFilter
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoFilters">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoFilters
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.writeToStream">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>writeToStream
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.jsdoc_aliases">module fluent-ffmpeg.jsdoc_aliases</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.jsdoc_aliases.defineTags">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.jsdoc_aliases.</span>defineTags
            <span class="apidocSignatureSpan">(dict)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.jsdoc_aliases.</span>handlers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.podcast">module fluent-ffmpeg.podcast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.podcast.load">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.podcast.</span>load
            <span class="apidocSignatureSpan">(ffmpeg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fluent-ffmpeg.utils">module fluent-ffmpeg.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.args">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>args
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.copy">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>copy
            <span class="apidocSignatureSpan">(source, dest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.extractCodecData">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractCodecData
            <span class="apidocSignatureSpan">(command, stderrLine, codecsObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.extractError">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractError
            <span class="apidocSignatureSpan">(stderr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.extractProgress">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractProgress
            <span class="apidocSignatureSpan">(command, stderrLine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.linesRing">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>linesRing
            <span class="apidocSignatureSpan">(maxLines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.makeFilterStrings">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>makeFilterStrings
            <span class="apidocSignatureSpan">(filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.timemarkToSeconds">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>timemarkToSeconds
            <span class="apidocSignatureSpan">(timemark)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fluent-ffmpeg.utils.which">
            function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>which
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>isWindows</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>streamRegexp</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg" id="apidoc.module.fluent-ffmpeg">module fluent-ffmpeg</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent-ffmpeg" id="apidoc.element.fluent-ffmpeg.fluent-ffmpeg">
        function <span class="apidocSignatureSpan"></span>fluent-ffmpeg
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FfmpegCommand(input, options) {
  // Make &#x27;new&#x27; optional
  if (!(this instanceof FfmpegCommand)) {
    return new FfmpegCommand(input, options);
  }

  EventEmitter.call(this);

  if (typeof input === &#x27;object&#x27; &#x26;&#x26; !(&#x27;readable&#x27; in input)) {
    // Options object passed directly
    options = input;
  } else {
    // Input passed first
    options = options || {};
    options.source = input;
  }

  // Add input if present
  this._inputs = [];
  if (options.source) {
    this.input(options.source);
  }

  // Add target-less output for backwards compatibility
  this._outputs = [];
  this.output();

  // Create argument lists
  var self = this;
  [&#x27;_global&#x27;, &#x27;_complexFilters&#x27;].forEach(function(prop) {
    self[prop] = utils.args();
  });

  // Set default option values
  options.stdoutLines = &#x27;stdoutLines&#x27; in options ? options.stdoutLines : 100;
  options.presets = options.presets || options.preset || path.join(__dirname, &#x27;presets&#x27;);
  options.niceness = options.niceness || options.priority || 0;

  // Save options
  this.options = options;

  // Setup logger
  this.logger = options.logger || {
    debug: function() {},
    info: function() {},
    warn: function() {},
    error: function() {}
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableCodecs" id="apidoc.element.fluent-ffmpeg.availableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableCodecs = function (callback) {
  (new FfmpegCommand()).availableCodecs(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableEncoders" id="apidoc.element.fluent-ffmpeg.availableEncoders">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableEncoders
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableEncoders = function (callback) {
  (new FfmpegCommand()).availableEncoders(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

cb();
      },

      // Get available codecs
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableEncoders</span>(cb);
      },

      // Check whether specified codecs are available and add strict experimental options if needed
      function(encoders, cb) {
var unavailable;

// Audio codec(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableFilters" id="apidoc.element.fluent-ffmpeg.availableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFilters = function (callback) {
  (new FfmpegCommand()).availableFilters(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.availableFormats" id="apidoc.element.fluent-ffmpeg.availableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>availableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFormats = function (callback) {
  (new FfmpegCommand()).availableFormats(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @private
   */
  proto._checkCapabilities = function(callback) {
    var self = this;
    async.waterfall([
      // Get available formats
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableFormats</span>(cb);
      },

      // Check whether specified formats are available
      function(formats, cb) {
var unavailable;

// Output format(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.ffprobe" id="apidoc.element.fluent-ffmpeg.ffprobe">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>ffprobe
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ffprobe = function (file) {
  var instance = new FfmpegCommand(file);
  instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function runFfprobe(command) {
const inputProbeIndex = 0;
if (command._inputs[inputProbeIndex].isStream) {
  // Don&#x27;t probe input streams as this will consume them
  return;
}
command.<span class="apidocCodeKeywordSpan">ffprobe</span>(inputProbeIndex, function(err, data) {
  command._ffprobeData = data;
});
}


module.exports = function(proto) {
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>fluent_ffmpeg
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FfmpegCommand(input, options) {
  // Make &#x27;new&#x27; optional
  if (!(this instanceof FfmpegCommand)) {
    return new FfmpegCommand(input, options);
  }

  EventEmitter.call(this);

  if (typeof input === &#x27;object&#x27; &#x26;&#x26; !(&#x27;readable&#x27; in input)) {
    // Options object passed directly
    options = input;
  } else {
    // Input passed first
    options = options || {};
    options.source = input;
  }

  // Add input if present
  this._inputs = [];
  if (options.source) {
    this.input(options.source);
  }

  // Add target-less output for backwards compatibility
  this._outputs = [];
  this.output();

  // Create argument lists
  var self = this;
  [&#x27;_global&#x27;, &#x27;_complexFilters&#x27;].forEach(function(prop) {
    self[prop] = utils.args();
  });

  // Set default option values
  options.stdoutLines = &#x27;stdoutLines&#x27; in options ? options.stdoutLines : 100;
  options.presets = options.presets || options.preset || path.join(__dirname, &#x27;presets&#x27;);
  options.niceness = options.niceness || options.priority || 0;

  // Save options
  this.options = options;

  // Setup logger
  this.logger = options.logger || {
    debug: function() {},
    info: function() {},
    warn: function() {},
    error: function() {}
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableCodecs" id="apidoc.element.fluent-ffmpeg.getAvailableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableCodecs = function (callback) {
  (new FfmpegCommand()).availableCodecs(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableEncoders" id="apidoc.element.fluent-ffmpeg.getAvailableEncoders">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableEncoders
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableEncoders = function (callback) {
  (new FfmpegCommand()).availableEncoders(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableFilters" id="apidoc.element.fluent-ffmpeg.getAvailableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFilters = function (callback) {
  (new FfmpegCommand()).availableFilters(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.getAvailableFormats" id="apidoc.element.fluent-ffmpeg.getAvailableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>getAvailableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFormats = function (callback) {
  (new FfmpegCommand()).availableFormats(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.setFfmpegPath" id="apidoc.element.fluent-ffmpeg.setFfmpegPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfmpegPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfmpegPath = function (path) {
  (new FfmpegCommand()).setFfmpegPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.setFfprobePath" id="apidoc.element.fluent-ffmpeg.setFfprobePath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFfprobePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfprobePath = function (path) {
  (new FfmpegCommand()).setFfprobePath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.setFlvtoolPath" id="apidoc.element.fluent-ffmpeg.setFlvtoolPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>setFlvtoolPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFlvtoolPath = function (path) {
  (new FfmpegCommand()).setFlvtoolPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.super_" id="apidoc.element.fluent-ffmpeg.super_">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.divx" id="apidoc.module.fluent-ffmpeg.divx">module fluent-ffmpeg.divx</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.divx.load" id="apidoc.element.fluent-ffmpeg.divx.load">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.divx.</span>load
        <span class="apidocSignatureSpan">(ffmpeg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (ffmpeg) {
  ffmpeg
    .format(&#x27;avi&#x27;)
    .videoBitrate(&#x27;1024k&#x27;)
    .videoCodec(&#x27;mpeg4&#x27;)
    .size(&#x27;720x?&#x27;)
    .audioBitrate(&#x27;128k&#x27;)
    .audioChannels(2)
    .audioCodec(&#x27;libmp3lame&#x27;)
    .outputOptions([&#x27;-vtag DIVX&#x27;]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  preset(this);
} else {
  try {
    var modulePath = path.join(this.options.presets, preset);
    var module = require(modulePath);

    if (typeof module.load === &#x27;function&#x27;) {
      module.<span class="apidocCodeKeywordSpan">load</span>(this);
    } else {
      throw new Error(&#x27;preset &#x27; + modulePath + &#x27; has no load() function&#x27;);
    }
  } catch (err) {
    throw new Error(&#x27;preset &#x27; + modulePath + &#x27; could not be loaded: &#x27; + err.message);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.flashvideo" id="apidoc.module.fluent-ffmpeg.flashvideo">module fluent-ffmpeg.flashvideo</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.flashvideo.load" id="apidoc.element.fluent-ffmpeg.flashvideo.load">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.flashvideo.</span>load
        <span class="apidocSignatureSpan">(ffmpeg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (ffmpeg) {
  ffmpeg
    .format(&#x27;flv&#x27;)
    .flvmeta()
    .size(&#x27;320x?&#x27;)
    .videoBitrate(&#x27;512k&#x27;)
    .videoCodec(&#x27;libx264&#x27;)
    .fps(24)
    .audioBitrate(&#x27;96k&#x27;)
    .audioCodec(&#x27;aac&#x27;)
    .audioFrequency(22050)
    .audioChannels(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  preset(this);
} else {
  try {
    var modulePath = path.join(this.options.presets, preset);
    var module = require(modulePath);

    if (typeof module.load === &#x27;function&#x27;) {
      module.<span class="apidocCodeKeywordSpan">load</span>(this);
    } else {
      throw new Error(&#x27;preset &#x27; + modulePath + &#x27; has no load() function&#x27;);
    }
  } catch (err) {
    throw new Error(&#x27;preset &#x27; + modulePath + &#x27; could not be loaded: &#x27; + err.message);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.fluent_ffmpeg" id="apidoc.module.fluent-ffmpeg.fluent_ffmpeg">module fluent-ffmpeg.fluent_ffmpeg</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.fluent_ffmpeg" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.fluent_ffmpeg">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.</span>fluent_ffmpeg
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FfmpegCommand(input, options) {
  // Make &#x27;new&#x27; optional
  if (!(this instanceof FfmpegCommand)) {
    return new FfmpegCommand(input, options);
  }

  EventEmitter.call(this);

  if (typeof input === &#x27;object&#x27; &#x26;&#x26; !(&#x27;readable&#x27; in input)) {
    // Options object passed directly
    options = input;
  } else {
    // Input passed first
    options = options || {};
    options.source = input;
  }

  // Add input if present
  this._inputs = [];
  if (options.source) {
    this.input(options.source);
  }

  // Add target-less output for backwards compatibility
  this._outputs = [];
  this.output();

  // Create argument lists
  var self = this;
  [&#x27;_global&#x27;, &#x27;_complexFilters&#x27;].forEach(function(prop) {
    self[prop] = utils.args();
  });

  // Set default option values
  options.stdoutLines = &#x27;stdoutLines&#x27; in options ? options.stdoutLines : 100;
  options.presets = options.presets || options.preset || path.join(__dirname, &#x27;presets&#x27;);
  options.niceness = options.niceness || options.priority || 0;

  // Save options
  this.options = options;

  // Setup logger
  this.logger = options.logger || {
    debug: function() {},
    info: function() {},
    warn: function() {},
    error: function() {}
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableCodecs" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableCodecs = function (callback) {
  (new FfmpegCommand()).availableCodecs(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableEncoders" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableEncoders">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableEncoders
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableEncoders = function (callback) {
  (new FfmpegCommand()).availableEncoders(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

cb();
      },

      // Get available codecs
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableEncoders</span>(cb);
      },

      // Check whether specified codecs are available and add strict experimental options if needed
      function(encoders, cb) {
var unavailable;

// Audio codec(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFilters = function (callback) {
  (new FfmpegCommand()).availableFilters(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableFormats" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.availableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>availableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFormats = function (callback) {
  (new FfmpegCommand()).availableFormats(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @private
   */
  proto._checkCapabilities = function(callback) {
    var self = this;
    async.waterfall([
      // Get available formats
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableFormats</span>(cb);
      },

      // Check whether specified formats are available
      function(formats, cb) {
var unavailable;

// Output format(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.ffprobe" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.ffprobe">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>ffprobe
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ffprobe = function (file) {
  var instance = new FfmpegCommand(file);
  instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function runFfprobe(command) {
const inputProbeIndex = 0;
if (command._inputs[inputProbeIndex].isStream) {
  // Don&#x27;t probe input streams as this will consume them
  return;
}
command.<span class="apidocCodeKeywordSpan">ffprobe</span>(inputProbeIndex, function(err, data) {
  command._ffprobeData = data;
});
}


module.exports = function(proto) {
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableCodecs" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableCodecs = function (callback) {
  (new FfmpegCommand()).availableCodecs(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableEncoders" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableEncoders">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableEncoders
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableEncoders = function (callback) {
  (new FfmpegCommand()).availableEncoders(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFilters = function (callback) {
  (new FfmpegCommand()).availableFilters(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableFormats" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.getAvailableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>getAvailableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFormats = function (callback) {
  (new FfmpegCommand()).availableFormats(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFfmpegPath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFfmpegPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>setFfmpegPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfmpegPath = function (path) {
  (new FfmpegCommand()).setFfmpegPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFfprobePath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFfprobePath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>setFfprobePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfprobePath = function (path) {
  (new FfmpegCommand()).setFfprobePath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFlvtoolPath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.setFlvtoolPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>setFlvtoolPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFlvtoolPath = function (path) {
  (new FfmpegCommand()).setFlvtoolPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.super_" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.super_">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.fluent_ffmpeg.prototype" id="apidoc.module.fluent-ffmpeg.fluent_ffmpeg.prototype">module fluent-ffmpeg.fluent_ffmpeg.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPS" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPS">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>FPS
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FPS = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPSInput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPSInput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>FPSInput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FPSInput = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPSOutput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.FPSOutput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>FPSOutput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FPSOutput = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._checkCapabilities" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._checkCapabilities">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_checkCapabilities
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkCapabilities = function (callback) {
  var self = this;
  async.waterfall([
    // Get available formats
    function(cb) {
      self.availableFormats(cb);
    },

    // Check whether specified formats are available
    function(formats, cb) {
      var unavailable;

      // Output format(s)
      unavailable = self._outputs
        .reduce(function(fmts, output) {
          var format = output.options.find(&#x27;-f&#x27;, 1);
          if (format) {
            if (!(format[0] in formats) || !(formats[format[0]].canMux)) {
              fmts.push(format);
            }
          }

          return fmts;
        }, []);

      if (unavailable.length === 1) {
        return cb(new Error(&#x27;Output format &#x27; + unavailable[0] + &#x27; is not available&#x27;));
      } else if (unavailable.length &#x3e; 1) {
        return cb(new Error(&#x27;Output formats &#x27; + unavailable.join(&#x27;, &#x27;) + &#x27; are not available&#x27;));
      }

      // Input format(s)
      unavailable = self._inputs
        .reduce(function(fmts, input) {
          var format = input.options.find(&#x27;-f&#x27;, 1);
          if (format) {
            if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {
              fmts.push(format[0]);
            }
          }

          return fmts;
        }, []);

      if (unavailable.length === 1) {
        return cb(new Error(&#x27;Input format &#x27; + unavailable[0] + &#x27; is not available&#x27;));
      } else if (unavailable.length &#x3e; 1) {
        return cb(new Error(&#x27;Input formats &#x27; + unavailable.join(&#x27;, &#x27;) + &#x27; are not available&#x27;));
      }

      cb();
    },

    // Get available codecs
    function(cb) {
      self.availableEncoders(cb);
    },

    // Check whether specified codecs are available and add strict experimental options if needed
    function(encoders, cb) {
      var unavailable;

      // Audio codec(s)
      unavailable = self._outputs.reduce(function(cdcs, output) {
        var acodec = output.audio.find(&#x27;-acodec&#x27;, 1);
        if (acodec &#x26;&#x26; acodec[0] !== &#x27;copy&#x27;) {
          if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== &#x27;audio&#x27;) {
            cdcs.push(acodec[0]);
          }
        }

        return cdcs;
      }, []);

      if (unavailable.length === 1) {
        return cb(new Error(&#x27;Audio codec &#x27; + unavailable[0] + &#x27; is not available&#x27;));
      } else if (unavailable.length &#x3e; 1) {
        return cb(new Error(&#x27;Audio codecs &#x27; + unavailable.join(&#x27;, &#x27;) + &#x27; are not available&#x27;));
      }

      // Video codec(s)
      unavailable = self._outputs.reduce(function(cdcs, output) {
        var vcodec = output.video.find(&#x27;-vcodec&#x27;, 1);
        if (vcodec &#x26;&#x26; vcodec[0] !== &#x27;copy&#x27;) {
          if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== &#x27;video&#x27;) {
            cdcs.push(vcodec[0]);
          }
        }

        return cdcs;
      }, []);

      if (unavailable.length === 1) {
        return cb(new Error(&#x27;Video codec &#x27; + unavailable[0] + &#x27; is not available&#x27;));
      } else if (unavailable.length &#x3e; 1) {
        return cb(new Error(&#x27;Video codecs &#x27; + unavailable.join(&#x27;, &#x27;) + &#x27; are not available&#x27;));
      }

      cb();
    }
  ], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  proto._prepare = function(callback, readMetadata) {
    var self = this;

    async.waterfall([
// Check codecs and formats
function(cb) {
  self.<span class="apidocCodeKeywordSpan">_checkCapabilities</span>(cb);
},

// Read metadata if required
function(cb) {
  if (!readMetadata) {
    return cb();
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._forgetPaths" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._forgetPaths">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_forgetPaths
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_forgetPaths = function () {
  delete cache.ffmpegPath;
  delete cache.ffprobePath;
  delete cache.flvtoolPath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getArguments" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getArguments">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getArguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getArguments = function () {
  var complexFilters = this._complexFilters.get();

  var fileOutput = this._outputs.some(function(output) {
    return output.isFile;
  });

  return [].concat(
      // Inputs and input options
      this._inputs.reduce(function(args, input) {
        var source = (typeof input.source === &#x27;string&#x27;) ? input.source : &#x27;pipe:0&#x27;;

        // For each input, add input options, then &#x27;-i &#x3c;source&#x3e;&#x27;
        return args.concat(
          input.options.get(),
          [&#x27;-i&#x27;, source]
        );
      }, []),

      // Global options
      this._global.get(),

      // Overwrite if we have file outputs
      fileOutput ? [&#x27;-y&#x27;] : [],

      // Complex filters
      complexFilters,

      // Outputs, filters and output options
      this._outputs.reduce(function(args, output) {
        var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());
        var audioFilters = output.audioFilters.get();
        var videoFilters = output.videoFilters.get().concat(sizeFilters);
        var outputArg;

        if (!output.target) {
          outputArg = [];
        } else if (typeof output.target === &#x27;string&#x27;) {
          outputArg = [output.target];
        } else {
          outputArg = [&#x27;pipe:1&#x27;];
        }

        return args.concat(
          output.audio.get(),
          audioFilters.length ? [&#x27;-filter:a&#x27;, audioFilters.join(&#x27;,&#x27;)] : [],
          output.video.get(),
          videoFilters.length ? [&#x27;-filter:v&#x27;, videoFilters.join(&#x27;,&#x27;)] : [],
          output.options.get(),
          outputArg
        );
      }, [])
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},

// Build argument list
function(cb) {
  var args;
  try {
    args = self.<span class="apidocCodeKeywordSpan">_getArguments</span>();
  } catch(e) {
    return cb(e);
  }

  cb(null, args);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFfmpegPath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFfmpegPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getFfmpegPath
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFfmpegPath = function (callback) {
  if (&#x27;ffmpegPath&#x27; in cache) {
    return callback(null, cache.ffmpegPath);
  }

  async.waterfall([
    // Try FFMPEG_PATH
    function(cb) {
      if (process.env.FFMPEG_PATH) {
        fs.exists(process.env.FFMPEG_PATH, function(exists) {
          if (exists) {
            cb(null, process.env.FFMPEG_PATH);
          } else {
            cb(null, &#x27;&#x27;);
          }
        });
      } else {
        cb(null, &#x27;&#x27;);
      }
    },

    // Search in the PATH
    function(ffmpeg, cb) {
      if (ffmpeg.length) {
        return cb(null, ffmpeg);
      }

      utils.which(&#x27;ffmpeg&#x27;, function(err, ffmpeg) {
        cb(err, ffmpeg);
      });
    }
  ], function(err, ffmpeg) {
    if (err) {
      callback(err);
    } else {
      callback(null, cache.ffmpegPath = (ffmpeg || &#x27;&#x27;));
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      // Search in the same directory as ffmpeg
      function(ffprobe, cb) {
if (ffprobe.length) {
  return cb(null, ffprobe);
}

self.<span class="apidocCodeKeywordSpan">_getFfmpegPath</span>(function(err, ffmpeg) {
  if (err) {
    cb(err);
  } else if (ffmpeg.length) {
    var name = utils.isWindows ? &#x27;ffprobe.exe&#x27; : &#x27;ffprobe&#x27;;
    var ffprobe = path.join(path.dirname(ffmpeg), name);
    fs.exists(ffprobe, function(exists) {
      cb(null, exists ? ffprobe : &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFfprobePath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFfprobePath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getFfprobePath
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFfprobePath = function (callback) {
  var self = this;

  if (&#x27;ffprobePath&#x27; in cache) {
    return callback(null, cache.ffprobePath);
  }

  async.waterfall([
    // Try FFPROBE_PATH
    function(cb) {
      if (process.env.FFPROBE_PATH) {
        fs.exists(process.env.FFPROBE_PATH, function(exists) {
          cb(null, exists ? process.env.FFPROBE_PATH : &#x27;&#x27;);
        });
      } else {
        cb(null, &#x27;&#x27;);
      }
    },

    // Search in the PATH
    function(ffprobe, cb) {
      if (ffprobe.length) {
        return cb(null, ffprobe);
      }

      utils.which(&#x27;ffprobe&#x27;, function(err, ffprobe) {
        cb(err, ffprobe);
      });
    },

    // Search in the same directory as ffmpeg
    function(ffprobe, cb) {
      if (ffprobe.length) {
        return cb(null, ffprobe);
      }

      self._getFfmpegPath(function(err, ffmpeg) {
        if (err) {
          cb(err);
        } else if (ffmpeg.length) {
          var name = utils.isWindows ? &#x27;ffprobe.exe&#x27; : &#x27;ffprobe&#x27;;
          var ffprobe = path.join(path.dirname(ffmpeg), name);
          fs.exists(ffprobe, function(exists) {
            cb(null, exists ? ffprobe : &#x27;&#x27;);
          });
        } else {
          cb(null, &#x27;&#x27;);
        }
      });
    }
  ], function(err, ffprobe) {
    if (err) {
      callback(err);
    } else {
      callback(null, cache.ffprobePath = (ffprobe || &#x27;&#x27;));
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!input) {
  return handleCallback(new Error(&#x27;Invalid input index&#x27;));
}
    }

    // Find ffprobe
    this.<span class="apidocCodeKeywordSpan">_getFfprobePath</span>(function(err, path) {
if (err) {
  return handleCallback(err);
} else if (!path) {
  return handleCallback(new Error(&#x27;Cannot find ffprobe&#x27;));
}

var stdout = &#x27;&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFlvtoolPath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._getFlvtoolPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_getFlvtoolPath
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFlvtoolPath = function (callback) {
  if (&#x27;flvtoolPath&#x27; in cache) {
    return callback(null, cache.flvtoolPath);
  }

  async.waterfall([
    // Try FLVMETA_PATH
    function(cb) {
      if (process.env.FLVMETA_PATH) {
        fs.exists(process.env.FLVMETA_PATH, function(exists) {
          cb(null, exists ? process.env.FLVMETA_PATH : &#x27;&#x27;);
        });
      } else {
        cb(null, &#x27;&#x27;);
      }
    },

    // Try FLVTOOL2_PATH
    function(flvtool, cb) {
      if (flvtool.length) {
        return cb(null, flvtool);
      }

      if (process.env.FLVTOOL2_PATH) {
        fs.exists(process.env.FLVTOOL2_PATH, function(exists) {
          cb(null, exists ? process.env.FLVTOOL2_PATH : &#x27;&#x27;);
        });
      } else {
        cb(null, &#x27;&#x27;);
      }
    },

    // Search for flvmeta in the PATH
    function(flvtool, cb) {
      if (flvtool.length) {
        return cb(null, flvtool);
      }

      utils.which(&#x27;flvmeta&#x27;, function(err, flvmeta) {
        cb(err, flvmeta);
      });
    },

    // Search for flvtool2 in the PATH
    function(flvtool, cb) {
      if (flvtool.length) {
        return cb(null, flvtool);
      }

      utils.which(&#x27;flvtool2&#x27;, function(err, flvtool2) {
        cb(err, flvtool2);
      });
    },
  ], function(err, flvtool) {
    if (err) {
      callback(err);
    } else {
      callback(null, cache.flvtoolPath = (flvtool || &#x27;&#x27;));
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      output.flags.flvmeta = false;
    }

    return output.flags.flvmeta;
  });

  if (flvmeta) {
    self.<span class="apidocCodeKeywordSpan">_getFlvtoolPath</span>(function(err) {
      cb(err);
    });
  } else {
    cb();
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._prepare" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._prepare">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_prepare
        <span class="apidocSignatureSpan">(callback, readMetadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_prepare = function (callback, readMetadata) {
  var self = this;

  async.waterfall([
    // Check codecs and formats
    function(cb) {
      self._checkCapabilities(cb);
    },

    // Read metadata if required
    function(cb) {
      if (!readMetadata) {
        return cb();
      }

      self.ffprobe(0, function(err, data) {
        if (!err) {
          self._ffprobeData = data;
        }

        cb();
      });
    },

    // Check for flvtool2/flvmeta if necessary
    function(cb) {
      var flvmeta = self._outputs.some(function(output) {
        // Remove flvmeta flag on non-file output
        if (output.flags.flvmeta &#x26;&#x26; !output.isFile) {
          self.logger.warn(&#x27;Updating flv metadata is only supported for files&#x27;);
          output.flags.flvmeta = false;
        }

        return output.flags.flvmeta;
      });

      if (flvmeta) {
        self._getFlvtoolPath(function(err) {
          cb(err);
        });
      } else {
        cb();
      }
    },

    // Build argument list
    function(cb) {
      var args;
      try {
        args = self._getArguments();
      } catch(e) {
        return cb(e);
      }

      cb(null, args);
    },

    // Add &#x22;-strict experimental&#x22; option where needed
    function(args, cb) {
      self.availableEncoders(function(err, encoders) {
        for (var i = 0; i &#x3c; args.length; i++) {
          if (args[i] === &#x27;-acodec&#x27; || args[i] === &#x27;-vcodec&#x27;) {
            i++;

            if ((args[i] in encoders) &#x26;&#x26; encoders[args[i]].experimental) {
              args.splice(i + 1, 0, &#x27;-strict&#x27;, &#x27;experimental&#x27;);
              i += 2;
            }
          }
        }

        cb(null, args);
      });
    }
  ], callback);

  if (!readMetadata) {
    // Read metadata as soon as &#x27;progress&#x27; listeners are added

    if (this.listeners(&#x27;progress&#x27;).length &#x3e; 0) {
      // Read metadata in parallel
      runFfprobe(this);
    } else {
      // Read metadata as soon as the first &#x27;progress&#x27; listener is added
      this.once(&#x27;newListener&#x27;, function(event) {
        if (event === &#x27;progress&#x27;) {
          runFfprobe(this);
        }
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.emit(&#x27;error&#x27;, err, stdout, stderr);
  } else {
    self.emit(&#x27;end&#x27;, stdout, stderr);
  }
}
    }

    self.<span class="apidocCodeKeywordSpan">_prepare</span>(function(err, args) {
if (err) {
  return emitEnd(err);
}

// Run ffmpeg
self._spawnFfmpeg(
  args,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._spawnFfmpeg" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype._spawnFfmpeg">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>_spawnFfmpeg
        <span class="apidocSignatureSpan">(args, options, processCB, endCB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_spawnFfmpeg = function (args, options, processCB, endCB) {
  // Enable omitting options
  if (typeof options === &#x27;function&#x27;) {
    endCB = processCB;
    processCB = options;
    options = {};
  }

  // Enable omitting processCB
  if (typeof endCB === &#x27;undefined&#x27;) {
    endCB = processCB;
    processCB = function() {};
  }

  var maxLines = &#x27;stdoutLines&#x27; in options ? options.stdoutLines : this.options.stdoutLines;

  // Find ffmpeg
  this._getFfmpegPath(function(err, command) {
    if (err) {
      return endCB(err);
    } else if (!command || command.length === 0) {
      return endCB(new Error(&#x27;Cannot find ffmpeg&#x27;));
    }

    // Apply niceness
    if (options.niceness &#x26;&#x26; options.niceness !== 0 &#x26;&#x26; !utils.isWindows) {
      args.unshift(&#x27;-n&#x27;, options.niceness, command);
      command = &#x27;nice&#x27;;
    }

    var stdoutRing = utils.linesRing(maxLines);
    var stdoutClosed = false;

    var stderrRing = utils.linesRing(maxLines);
    var stderrClosed = false;

    // Spawn process
    var ffmpegProc = spawn(command, args, options);

    if (ffmpegProc.stderr) {
      ffmpegProc.stderr.setEncoding(&#x27;utf8&#x27;);
    }

    ffmpegProc.on(&#x27;error&#x27;, function(err) {
      endCB(err);
    });

    // Ensure we wait for captured streams to end before calling endCB
    var exitError = null;
    function handleExit(err) {
      if (err) {
        exitError = err;
      }

      if (processExited &#x26;&#x26; (stdoutClosed || !options.captureStdout) &#x26;&#x26; stderrClosed) {
        endCB(exitError, stdoutRing, stderrRing);
      }
    }

    // Handle process exit
    var processExited = false;
    ffmpegProc.on(&#x27;exit&#x27;, function(code, signal) {
      processExited = true;

      if (signal) {
        handleExit(new Error(&#x27;ffmpeg was killed with signal &#x27; + signal));
      } else if (code) {
        handleExit(new Error(&#x27;ffmpeg exited with code &#x27; + code));
      } else {
        handleExit();
      }
    });

    // Capture stdout if specified
    if (options.captureStdout) {
      ffmpegProc.stdout.on(&#x27;data&#x27;, function(data) {
        stdoutRing.append(data);
      });

      ffmpegProc.stdout.on(&#x27;close&#x27;, function() {
        stdoutRing.close();
        stdoutClosed = true;
        handleExit();
      });
    }

    // Capture stderr if specified
    ffmpegProc.stderr.on(&#x27;data&#x27;, function(data) {
      stderrRing.append(data);
    });

    ffmpegProc.stderr.on(&#x27;close&#x27;, function() {
      stderrRing.close();
      stderrClosed = true;
      handleExit();
    });

    // Call process callback
    processCB(ffmpegProc, stdoutRing, stderrRing);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  proto.availableFilters =
  proto.getAvailableFilters = function(callback) {
    if (&#x27;filters&#x27; in cache) {
return callback(null, cache.filters);
    }

    this.<span class="apidocCodeKeywordSpan">_spawnFfmpeg</span>([&#x27;-filters&#x27;], { captureStdout: true, stdoutLines: 0 },
function (err, stdoutRing) {
if (err) {
  return callback(err);
}

var stdout = stdoutRing.get();
var lines = stdout.split(&#x27;\n&#x27;);
var data = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addInput
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addInput = function (source) {
  var isFile = false;
  var isStream = false;

  if (typeof source !== &#x27;string&#x27;) {
    if (!(&#x27;readable&#x27; in source) || !(source.readable)) {
      throw new Error(&#x27;Invalid input&#x27;);
    }

    var hasInputStream = this._inputs.some(function(input) {
      return input.isStream;
    });

    if (hasInputStream) {
      throw new Error(&#x27;Only one input stream is supported&#x27;);
    }

    isStream = true;
    source.pause();
  } else {
    var protocol = source.match(/^([a-z]{2,}):/i);
    isFile = !protocol || protocol[0] === &#x27;file&#x27;;
  }

  this._inputs.push(this._currentInput = {
    source: source,
    isFile: isFile,
    isStream: isStream,
    options: utils.args()
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInputOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInputOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addInputOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addInputOption = function (options) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentInput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInputOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addInputOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addInputOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addInputOptions = function (options) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentInput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOption = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOptions = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOutput
        <span class="apidocSignatureSpan">(target, pipeopts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOutput = function (target, pipeopts) {
  var isFile = false;

  if (!target &#x26;&#x26; this._currentOutput) {
    // No target is only allowed when called from constructor
    throw new Error(&#x27;Invalid output&#x27;);
  }

  if (target &#x26;&#x26; typeof target !== &#x27;string&#x27;) {
    if (!(&#x27;writable&#x27; in target) || !(target.writable)) {
      throw new Error(&#x27;Invalid output&#x27;);
    }
  } else if (typeof target === &#x27;string&#x27;) {
    var protocol = target.match(/^([a-z]{2,}):/i);
    isFile = !protocol || protocol[0] === &#x27;file&#x27;;
  }

  if (target &#x26;&#x26; !(&#x27;target&#x27; in this._currentOutput)) {
    // For backwards compatibility, set target for first output
    this._currentOutput.target = target;
    this._currentOutput.isFile = isFile;
    this._currentOutput.pipeopts = pipeopts || {};
  } else {
    if (target &#x26;&#x26; typeof target !== &#x27;string&#x27;) {
      var hasOutputStream = this._outputs.some(function(output) {
        return typeof output.target !== &#x27;string&#x27;;
      });

      if (hasOutputStream) {
        throw new Error(&#x27;Only one output stream is supported&#x27;);
      }
    }

    this._outputs.push(this._currentOutput = {
      target: target,
      isFile: isFile,
      flags: {},
      pipeopts: pipeopts || {}
    });

    var self = this;
    [&#x27;audio&#x27;, &#x27;audioFilters&#x27;, &#x27;video&#x27;, &#x27;videoFilters&#x27;, &#x27;sizeFilters&#x27;, &#x27;options&#x27;].forEach(function(key) {
      self._currentOutput[key] = utils.args();
    });

    if (!target) {
      // Call from constructor: remove target key
      delete this._currentOutput.target;
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutputOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutputOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOutputOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOutputOption = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutputOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.addOutputOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>addOutputOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOutputOptions = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutoPad" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutoPad">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutoPad
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyAutoPad = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutoPadding" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutoPadding">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutoPadding
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyAutoPadding = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutopad" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutopad">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutopad
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyAutopad = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutopadding" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.applyAutopadding">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>applyAutopadding
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyAutopadding = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.aspect" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.aspect">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>aspect
        <span class="apidocSignatureSpan">(aspect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aspect = function (aspect) {
  var a = Number(aspect);
  if (isNaN(a)) {
    var match = aspect.match(/^(\d+):(\d+)$/);
    if (match) {
      a = Number(match[1]) / Number(match[2]);
    } else {
      throw new Error(&#x27;Invalid aspect ratio: &#x27; + aspect);
    }
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;aspect&#x27;, a);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.aspectRatio" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.aspectRatio">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>aspectRatio
        <span class="apidocSignatureSpan">(aspect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aspectRatio = function (aspect) {
  var a = Number(aspect);
  if (isNaN(a)) {
    var match = aspect.match(/^(\d+):(\d+)$/);
    if (match) {
      a = Number(match[1]) / Number(match[2]);
    } else {
      throw new Error(&#x27;Invalid aspect ratio: &#x27; + aspect);
    }
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;aspect&#x27;, a);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioBitrate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioBitrate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioBitrate
        <span class="apidocSignatureSpan">(bitrate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioBitrate = function (bitrate) {
  this._currentOutput.audio(&#x27;-b:a&#x27;, (&#x27;&#x27; + bitrate).replace(/k?$/, &#x27;k&#x27;));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.load = function(ffmpeg) {
  ffmpeg
    .format(&#x27;avi&#x27;)
    .videoBitrate(&#x27;1024k&#x27;)
    .videoCodec(&#x27;mpeg4&#x27;)
    .size(&#x27;720x?&#x27;)
    .<span class="apidocCodeKeywordSpan">audioBitrate</span>(&#x27;128k&#x27;)
    .audioChannels(2)
    .audioCodec(&#x27;libmp3lame&#x27;)
    .outputOptions([&#x27;-vtag DIVX&#x27;]);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioChannels" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioChannels">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioChannels
        <span class="apidocSignatureSpan">(channels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioChannels = function (channels) {
  this._currentOutput.audio(&#x27;-ac&#x27;, channels);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.load = function(ffmpeg) {
  ffmpeg
    .format(&#x27;avi&#x27;)
    .videoBitrate(&#x27;1024k&#x27;)
    .videoCodec(&#x27;mpeg4&#x27;)
    .size(&#x27;720x?&#x27;)
    .audioBitrate(&#x27;128k&#x27;)
    .<span class="apidocCodeKeywordSpan">audioChannels</span>(2)
    .audioCodec(&#x27;libmp3lame&#x27;)
    .outputOptions([&#x27;-vtag DIVX&#x27;]);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioCodec" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioCodec">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioCodec
        <span class="apidocSignatureSpan">(codec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioCodec = function (codec) {
  this._currentOutput.audio(&#x27;-acodec&#x27;, codec);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ffmpeg
    .format(&#x27;avi&#x27;)
    .videoBitrate(&#x27;1024k&#x27;)
    .videoCodec(&#x27;mpeg4&#x27;)
    .size(&#x27;720x?&#x27;)
    .audioBitrate(&#x27;128k&#x27;)
    .audioChannels(2)
    .<span class="apidocCodeKeywordSpan">audioCodec</span>(&#x27;libmp3lame&#x27;)
    .outputOptions([&#x27;-vtag DIVX&#x27;]);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFilter" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFilter">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioFilter
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioFilter = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.audioFilters(utils.makeFilterStrings(filters));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioFilters
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioFilters = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.audioFilters(utils.makeFilterStrings(filters));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Specify custom audio filter(s)
*
* Can be called both with one or many filters, or a filter array.
*
* @example
* command.<span class="apidocCodeKeywordSpan">audioFilters</span>(&#x27;filter1&#x27;);
*
* @example
* command.audioFilters(&#x27;filter1&#x27;, &#x27;filter2=param1=value1:param2=value2&#x27;);
*
* @example
* command.audioFilters([&#x27;filter1&#x27;, &#x27;filter2&#x27;]);
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFrequency" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioFrequency">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioFrequency
        <span class="apidocSignatureSpan">(freq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioFrequency = function (freq) {
  this._currentOutput.audio(&#x27;-ar&#x27;, freq);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioQuality" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.audioQuality">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>audioQuality
        <span class="apidocSignatureSpan">(quality)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">audioQuality = function (quality) {
  this._currentOutput.audio(&#x27;-aq&#x27;, quality);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.autoPad" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.autoPad">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>autoPad
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoPad = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.autopad" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.autopad">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>autopad
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autopad = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableCodecs" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableCodecs = function (callback) {
  if (&#x27;codecs&#x27; in cache) {
    return callback(null, cache.codecs);
  }

  this._spawnFfmpeg([&#x27;-codecs&#x27;], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    var stdout = stdoutRing.get();
    var lines = stdout.split(lineBreakRegexp);
    var data = {};

    lines.forEach(function(line) {
      var match = line.match(avCodecRegexp);
      if (match &#x26;&#x26; match[7] !== &#x27;=&#x27;) {
        data[match[7]] = {
          type: { &#x27;V&#x27;: &#x27;video&#x27;, &#x27;A&#x27;: &#x27;audio&#x27;, &#x27;S&#x27;: &#x27;subtitle&#x27; }[match[3]],
          description: match[8],
          canDecode: match[1] === &#x27;D&#x27;,
          canEncode: match[2] === &#x27;E&#x27;,
          drawHorizBand: match[4] === &#x27;S&#x27;,
          directRendering: match[5] === &#x27;D&#x27;,
          weirdFrameTruncation: match[6] === &#x27;T&#x27;
        };
      }

      match = line.match(ffCodecRegexp);
      if (match &#x26;&#x26; match[7] !== &#x27;=&#x27;) {
        var codecData = data[match[7]] = {
          type: { &#x27;V&#x27;: &#x27;video&#x27;, &#x27;A&#x27;: &#x27;audio&#x27;, &#x27;S&#x27;: &#x27;subtitle&#x27; }[match[3]],
          description: match[8],
          canDecode: match[1] === &#x27;D&#x27;,
          canEncode: match[2] === &#x27;E&#x27;,
          intraFrameOnly: match[4] === &#x27;I&#x27;,
          isLossy: match[5] === &#x27;L&#x27;,
          isLossless: match[6] === &#x27;S&#x27;
        };

        var encoders = codecData.description.match(ffEncodersRegexp);
        encoders = encoders ? encoders[1].trim().split(&#x27; &#x27;) : [];

        var decoders = codecData.description.match(ffDecodersRegexp);
        decoders = decoders ? decoders[1].trim().split(&#x27; &#x27;) : [];

        if (encoders.length || decoders.length) {
          var coderData = {};
          utils.copy(codecData, coderData);
          delete coderData.canEncode;
          delete coderData.canDecode;

          encoders.forEach(function(name) {
            data[name] = {};
            utils.copy(coderData, data[name]);
            data[name].canEncode = true;
          });

          decoders.forEach(function(name) {
            if (name in data) {
              data[name].canDecode = true;
            } else {
              data[name] = {};
              utils.copy(coderData, data[name]);
              data[name].canDecode = true;
            }
          });
        }
      }
    });

    callback(null, cache.codecs = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableEncoders" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableEncoders">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableEncoders
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableEncoders = function (callback) {
  if (&#x27;encoders&#x27; in cache) {
    return callback(null, cache.encoders);
  }

  this._spawnFfmpeg([&#x27;-encoders&#x27;], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    var stdout = stdoutRing.get();
    var lines = stdout.split(lineBreakRegexp);
    var data = {};

    lines.forEach(function(line) {
      var match = line.match(encodersRegexp);
      if (match &#x26;&#x26; match[7] !== &#x27;=&#x27;) {
        data[match[7]] = {
          type: { &#x27;V&#x27;: &#x27;video&#x27;, &#x27;A&#x27;: &#x27;audio&#x27;, &#x27;S&#x27;: &#x27;subtitle&#x27; }[match[1]],
          description: match[8],
          frameMT: match[2] === &#x27;F&#x27;,
          sliceMT: match[3] === &#x27;S&#x27;,
          experimental: match[4] === &#x27;X&#x27;,
          drawHorizBand: match[5] === &#x27;B&#x27;,
          directRendering: match[6] === &#x27;D&#x27;
        };
      }
    });

    callback(null, cache.encoders = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

cb();
      },

      // Get available codecs
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableEncoders</span>(cb);
      },

      // Check whether specified codecs are available and add strict experimental options if needed
      function(encoders, cb) {
var unavailable;

// Audio codec(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFilters = function (callback) {
  if (&#x27;filters&#x27; in cache) {
    return callback(null, cache.filters);
  }

  this._spawnFfmpeg([&#x27;-filters&#x27;], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    var stdout = stdoutRing.get();
    var lines = stdout.split(&#x27;\n&#x27;);
    var data = {};
    var types = { A: &#x27;audio&#x27;, V: &#x27;video&#x27;, &#x27;|&#x27;: &#x27;none&#x27; };

    lines.forEach(function(line) {
      var match = line.match(filterRegexp);
      if (match) {
        data[match[1]] = {
          description: match[4],
          input: types[match[2].charAt(0)],
          multipleInputs: match[2].length &#x3e; 1,
          output: types[match[3].charAt(0)],
          multipleOutputs: match[3].length &#x3e; 1
        };
      }
    });

    callback(null, cache.filters = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableFormats" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.availableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>availableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">availableFormats = function (callback) {
  if (&#x27;formats&#x27; in cache) {
    return callback(null, cache.formats);
  }

  // Run ffmpeg -formats
  this._spawnFfmpeg([&#x27;-formats&#x27;], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    // Parse output
    var stdout = stdoutRing.get();
    var lines = stdout.split(lineBreakRegexp);
    var data = {};

    lines.forEach(function(line) {
      var match = line.match(formatRegexp);
      if (match) {
        match[3].split(&#x27;,&#x27;).forEach(function(format) {
          if (!(format in data)) {
            data[format] = {
              description: match[4],
              canDemux: false,
              canMux: false
            };
          }

          if (match[1] === &#x27;D&#x27;) {
            data[format].canDemux = true;
          }
          if (match[2] === &#x27;E&#x27;) {
            data[format].canMux = true;
          }
        });
      }
    });

    callback(null, cache.formats = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @private
   */
  proto._checkCapabilities = function(callback) {
    var self = this;
    async.waterfall([
      // Get available formats
      function(cb) {
self.<span class="apidocCodeKeywordSpan">availableFormats</span>(cb);
      },

      // Check whether specified formats are available
      function(formats, cb) {
var unavailable;

// Output format(s)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.clone" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.clone">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var clone = new FfmpegCommand();
  var self = this;

  // Clone options and logger
  clone.options = this.options;
  clone.logger = this.logger;

  // Clone inputs
  clone._inputs = this._inputs.map(function(input) {
    return {
      source: input.source,
      options: input.options.clone()
    };
  });

  // Create first output
  if (&#x27;target&#x27; in this._outputs[0]) {
    // We have outputs set, don&#x27;t clone them and create first output
    clone._outputs = [];
    clone.output();
  } else {
    // No outputs set, clone first output options
    clone._outputs = [
      clone._currentOutput = {
        flags: {}
      }
    ];

    [&#x27;audio&#x27;, &#x27;audioFilters&#x27;, &#x27;video&#x27;, &#x27;videoFilters&#x27;, &#x27;sizeFilters&#x27;, &#x27;options&#x27;].forEach(function(key) {
      clone._currentOutput[key] = self._currentOutput[key].clone();
    });

    if (this._currentOutput.sizeData) {
      clone._currentOutput.sizeData = {};
      utils.copy(this._currentOutput.sizeData, clone._currentOutput.sizeData);
    }

    utils.copy(this._currentOutput.flags, clone._currentOutput.flags);
  }

  // Clone argument lists
  [&#x27;_global&#x27;, &#x27;_complexFilters&#x27;].forEach(function(prop) {
    clone[prop] = self[prop].clone();
  });

  return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.complexFilter" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.complexFilter">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>complexFilter
        <span class="apidocSignatureSpan">(spec, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complexFilter = function (spec, map) {
  this._complexFilters.clear();

  if (!Array.isArray(spec)) {
    spec = [spec];
  }

  this._complexFilters(&#x27;-filter_complex&#x27;, utils.makeFilterStrings(spec).join(&#x27;;&#x27;));

  if (Array.isArray(map)) {
    var self = this;
    map.forEach(function(streamSpec) {
      self._complexFilters(&#x27;-map&#x27;, streamSpec.replace(utils.streamRegexp, &#x27;[$1]&#x27;));
    });
  } else if (typeof map === &#x27;string&#x27;) {
    this._complexFilters(&#x27;-map&#x27;, map.replace(utils.streamRegexp, &#x27;[$1]&#x27;));
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        .map(stream);

      if (i &#x3e; 0) {
        self.seek(config.timemarks[i] - first);
      }
    }

    self.<span class="apidocCodeKeywordSpan">complexFilter</span>(filters);
    self.run();
  });

  return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.concat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.concat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>concat
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (target, options) {
  // Find out which streams are present in the first non-stream input
  var fileInput = this._inputs.filter(function(input) {
    return !input.isStream;
  })[0];

  var self = this;
  this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {
    if (err) {
      return self.emit(&#x27;error&#x27;, err);
    }

    var hasAudioStreams = data.streams.some(function(stream) {
      return stream.codec_type === &#x27;audio&#x27;;
    });

    var hasVideoStreams = data.streams.some(function(stream) {
      return stream.codec_type === &#x27;video&#x27;;
    });

    // Setup concat filter and start processing
    self.output(target, options)
      .complexFilter({
        filter: &#x27;concat&#x27;,
        options: {
          n: self._inputs.length,
          v: hasVideoStreams ? 1 : 0,
          a: hasAudioStreams ? 1 : 0
        }
      })
      .run();
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stdout = &#x27;&#x27;;
var stdoutClosed = false;
var stderr = &#x27;&#x27;;
var stderrClosed = false;

// Spawn ffprobe
var src = input.isStream ? &#x27;pipe:0&#x27; : input.source;
var ffprobe = spawn(path, [&#x27;-show_streams&#x27;, &#x27;-show_format&#x27;].<span class="apidocCodeKeywordSpan">concat</span
>(options, src));

if (input.isStream) {
  // Skip errors on stdin. These get thrown when ffprobe is complete and
  // there seems to be no way hook in and close stdin before it throws.
  ffprobe.stdin.on(&#x27;error&#x27;, function(err) {
    if ([&#x27;ECONNRESET&#x27;, &#x27;EPIPE&#x27;].indexOf(err.code) &#x3e;= 0) { return; }
    handleCallback(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.concatenate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.concatenate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>concatenate
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatenate = function (target, options) {
  // Find out which streams are present in the first non-stream input
  var fileInput = this._inputs.filter(function(input) {
    return !input.isStream;
  })[0];

  var self = this;
  this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {
    if (err) {
      return self.emit(&#x27;error&#x27;, err);
    }

    var hasAudioStreams = data.streams.some(function(stream) {
      return stream.codec_type === &#x27;audio&#x27;;
    });

    var hasVideoStreams = data.streams.some(function(stream) {
      return stream.codec_type === &#x27;video&#x27;;
    });

    // Setup concat filter and start processing
    self.output(target, options)
      .complexFilter({
        filter: &#x27;concat&#x27;,
        options: {
          n: self._inputs.length,
          v: hasVideoStreams ? 1 : 0,
          a: hasAudioStreams ? 1 : 0
        }
      })
      .run();
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.duration" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.duration">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>duration
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duration = function (duration) {
  this._currentOutput.options(&#x27;-t&#x27;, duration);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!this._currentInput) {
      throw new Error(&#x27;No input specified&#x27;);
    }

    this._currentInput.options(&#x27;-loop&#x27;, &#x27;1&#x27;);

    if (typeof duration !== &#x27;undefined&#x27;) {
      this.<span class="apidocCodeKeywordSpan">duration</span>(duration);
    }

    return this;
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.exec" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.exec">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
  var self = this;

  // Check if at least one output is present
  var outputPresent = this._outputs.some(function(output) {
    return &#x27;target&#x27; in output;
  });

  if (!outputPresent) {
    throw new Error(&#x27;No output specified&#x27;);
  }

  // Get output stream if any
  var outputStream = this._outputs.filter(function(output) {
    return typeof output.target !== &#x27;string&#x27;;
  })[0];

  // Get input stream if any
  var inputStream = this._inputs.filter(function(input) {
    return typeof input.source !== &#x27;string&#x27;;
  })[0];

  // Ensure we send &#x27;end&#x27; or &#x27;error&#x27; only once
  var ended = false;
  function emitEnd(err, stdout, stderr) {
    if (!ended) {
      ended = true;

      if (err) {
        self.emit(&#x27;error&#x27;, err, stdout, stderr);
      } else {
        self.emit(&#x27;end&#x27;, stdout, stderr);
      }
    }
  }

  self._prepare(function(err, args) {
    if (err) {
      return emitEnd(err);
    }

    // Run ffmpeg
    self._spawnFfmpeg(
      args,
      {
        captureStdout: !outputStream,
        niceness: self.options.niceness,
        cwd: self.options.cwd
      },

      function processCB(ffmpegProc, stdoutRing, stderrRing) {
        self.ffmpegProc = ffmpegProc;
        self.emit(&#x27;start&#x27;, &#x27;ffmpeg &#x27; + args.join(&#x27; &#x27;));

        // Pipe input stream if any
        if (inputStream) {
          inputStream.source.on(&#x27;error&#x27;, function(err) {
            var reportingErr = new Error(&#x27;Input stream error: &#x27; + err.message);
            reportingErr.inputStreamError = err;
            emitEnd(reportingErr);
            ffmpegProc.kill();
          });

          inputStream.source.resume();
          inputStream.source.pipe(ffmpegProc.stdin);

          // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but
          // ffmpeg will fail anyway, so no need to actually handle anything)
          ffmpegProc.stdin.on(&#x27;error&#x27;, function() {});
        }

        // Setup timeout if requested
        var processTimer;
        if (self.options.timeout) {
          processTimer = setTimeout(function() {
            var msg = &#x27;process ran into a timeout (&#x27; + self.options.timeout + &#x27;s)&#x27;;

            emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());
            ffmpegProc.kill();
          }, self.options.timeout * 1000);
        }


        if (outputStream) {
          // Pipe ffmpeg stdout to output stream
          ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);

          // Handle output stream events
          outputStream.target.on(&#x27;close&#x27;, function() {
            self.logger.debug(&#x27;Output stream closed, scheduling kill for ffmpeg process&#x27;);

            // Don&#x27;t kill process yet, to give a chance to ffmpeg to
            // terminate successfully first  This is necessary because
            // under load, the process &#x27;exit&#x27; event sometimes happens
            // after the output stream &#x27;close&#x27; event.
            setTimeout(function() {
              emitEnd(new Error(&#x27;Output stream closed&#x27;));
              ffmpegProc.kill();
            }, 20);
          });

          outputStream.target.on(&#x27;error&#x27;, function(err) {
            self.logger.debug(&#x27;Output stream error, killing ffmpeg process&#x27;);
            var reportingErr = new Error(&#x27;Output stream error: &#x27; + err.message);
            reportingErr.outputStreamError = err;
            emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());
            ffmpegProc.kill(&#x27;SIGKILL&#x27;);
          });
        }

        // Setup stderr handling
        if (stderrRing) {

          // &#x27;stderr&#x27; event
          if (self.listeners(&#x27;stderr&#x27;).length) {
            stderrRing.callback(function(line) {
              self.emit(&#x27;stderr&#x27;, line);
            });
          }

          // &#x27;codecData&#x27; event
          if (self.listeners(&#x27;codecData&#x27;).length) {
            var codecDataSent = false;
            var codecObject = {};

            stderrRing.callback(function(line) {
              if (!codecDataSent)
                codecDataSent = utils.extractCodecData(self, line, codecObject);
            });
          }

          // &#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.execute" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.execute">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>execute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function () {
  var self = this;

  // Check if at least one output is present
  var outputPresent = this._outputs.some(function(output) {
    return &#x27;target&#x27; in output;
  });

  if (!outputPresent) {
    throw new Error(&#x27;No output specified&#x27;);
  }

  // Get output stream if any
  var outputStream = this._outputs.filter(function(output) {
    return typeof output.target !== &#x27;string&#x27;;
  })[0];

  // Get input stream if any
  var inputStream = this._inputs.filter(function(input) {
    return typeof input.source !== &#x27;string&#x27;;
  })[0];

  // Ensure we send &#x27;end&#x27; or &#x27;error&#x27; only once
  var ended = false;
  function emitEnd(err, stdout, stderr) {
    if (!ended) {
      ended = true;

      if (err) {
        self.emit(&#x27;error&#x27;, err, stdout, stderr);
      } else {
        self.emit(&#x27;end&#x27;, stdout, stderr);
      }
    }
  }

  self._prepare(function(err, args) {
    if (err) {
      return emitEnd(err);
    }

    // Run ffmpeg
    self._spawnFfmpeg(
      args,
      {
        captureStdout: !outputStream,
        niceness: self.options.niceness,
        cwd: self.options.cwd
      },

      function processCB(ffmpegProc, stdoutRing, stderrRing) {
        self.ffmpegProc = ffmpegProc;
        self.emit(&#x27;start&#x27;, &#x27;ffmpeg &#x27; + args.join(&#x27; &#x27;));

        // Pipe input stream if any
        if (inputStream) {
          inputStream.source.on(&#x27;error&#x27;, function(err) {
            var reportingErr = new Error(&#x27;Input stream error: &#x27; + err.message);
            reportingErr.inputStreamError = err;
            emitEnd(reportingErr);
            ffmpegProc.kill();
          });

          inputStream.source.resume();
          inputStream.source.pipe(ffmpegProc.stdin);

          // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but
          // ffmpeg will fail anyway, so no need to actually handle anything)
          ffmpegProc.stdin.on(&#x27;error&#x27;, function() {});
        }

        // Setup timeout if requested
        var processTimer;
        if (self.options.timeout) {
          processTimer = setTimeout(function() {
            var msg = &#x27;process ran into a timeout (&#x27; + self.options.timeout + &#x27;s)&#x27;;

            emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());
            ffmpegProc.kill();
          }, self.options.timeout * 1000);
        }


        if (outputStream) {
          // Pipe ffmpeg stdout to output stream
          ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);

          // Handle output stream events
          outputStream.target.on(&#x27;close&#x27;, function() {
            self.logger.debug(&#x27;Output stream closed, scheduling kill for ffmpeg process&#x27;);

            // Don&#x27;t kill process yet, to give a chance to ffmpeg to
            // terminate successfully first  This is necessary because
            // under load, the process &#x27;exit&#x27; event sometimes happens
            // after the output stream &#x27;close&#x27; event.
            setTimeout(function() {
              emitEnd(new Error(&#x27;Output stream closed&#x27;));
              ffmpegProc.kill();
            }, 20);
          });

          outputStream.target.on(&#x27;error&#x27;, function(err) {
            self.logger.debug(&#x27;Output stream error, killing ffmpeg process&#x27;);
            var reportingErr = new Error(&#x27;Output stream error: &#x27; + err.message);
            reportingErr.outputStreamError = err;
            emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());
            ffmpegProc.kill(&#x27;SIGKILL&#x27;);
          });
        }

        // Setup stderr handling
        if (stderrRing) {

          // &#x27;stderr&#x27; event
          if (self.listeners(&#x27;stderr&#x27;).length) {
            stderrRing.callback(function(line) {
              self.emit(&#x27;stderr&#x27;, line);
            });
          }

          // &#x27;codecData&#x27; event
          if (self.listeners(&#x27;codecData&#x27;).length) {
            var codecDataSent = false;
            var codecObject = {};

            stderrRing.callback(function(line) {
              if (!codecDataSent)
                codecDataSent = utils.extractCodecData(self, line, codecObject);
            });
          }

          // &#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.ffprobe" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.ffprobe">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>ffprobe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ffprobe = function () {
  var input, index = null, options = [], callback;

  // the last argument should be the callback
  var callback = arguments[arguments.length - 1];

  var ended = false
  function handleCallback(err, data) {
    if (!ended) {
      ended = true;
      callback(err, data);
    }
  };

  // map the arguments to the correct variable names
  switch (arguments.length) {
    case 3:
      index = arguments[0];
      options = arguments[1];
      break;
    case 2:
      if (typeof arguments[0] === &#x27;number&#x27;) {
        index = arguments[0];
      } else if (Array.isArray(arguments[0])) {
        options = arguments[0];
      }
      break;
  }


  if (index === null) {
    if (!this._currentInput) {
      return handleCallback(new Error(&#x27;No input specified&#x27;));
    }

    input = this._currentInput;
  } else {
    input = this._inputs[index];

    if (!input) {
      return handleCallback(new Error(&#x27;Invalid input index&#x27;));
    }
  }

  // Find ffprobe
  this._getFfprobePath(function(err, path) {
    if (err) {
      return handleCallback(err);
    } else if (!path) {
      return handleCallback(new Error(&#x27;Cannot find ffprobe&#x27;));
    }

    var stdout = &#x27;&#x27;;
    var stdoutClosed = false;
    var stderr = &#x27;&#x27;;
    var stderrClosed = false;

    // Spawn ffprobe
    var src = input.isStream ? &#x27;pipe:0&#x27; : input.source;
    var ffprobe = spawn(path, [&#x27;-show_streams&#x27;, &#x27;-show_format&#x27;].concat(options, src));

    if (input.isStream) {
      // Skip errors on stdin. These get thrown when ffprobe is complete and
      // there seems to be no way hook in and close stdin before it throws.
      ffprobe.stdin.on(&#x27;error&#x27;, function(err) {
        if ([&#x27;ECONNRESET&#x27;, &#x27;EPIPE&#x27;].indexOf(err.code) &#x3e;= 0) { return; }
        handleCallback(err);
      });

      // Once ffprobe&#x27;s input stream closes, we need no more data from the
      // input
      ffprobe.stdin.on(&#x27;close&#x27;, function() {
          input.source.pause();
          input.source.unpipe(ffprobe.stdin);
      });

      input.source.pipe(ffprobe.stdin);
    }

    ffprobe.on(&#x27;error&#x27;, callback);

    // Ensure we wait for captured streams to end before calling callback
    var exitError = null;
    function handleExit(err) {
      if (err) {
        exitError = err;
      }

      if (processExited &#x26;&#x26; stdoutClosed &#x26;&#x26; stderrClosed) {
        if (exitError) {
          if (stderr) {
            exitError.message += &#x27;\n&#x27; + stderr;
          }

          return handleCallback(exitError);
        }

        // Process output
        var data = parseFfprobeOutput(stdout);

        // Handle legacy output with &#x22;TAG:x&#x22; and &#x22;DISPOSITION:x&#x22; keys
        [data.format].concat(data.streams).forEach(function(target) {
          if (target) {
            var legacyTagKeys = Object.keys(target).filter(legacyTag);

            if (legacyTagKeys.length) {
              target.tags = target.tags || {};

              legacyTagKeys.forEach(function(tagKey) {
                target.tags[tagKey.substr(4)] = target[tagKey];
                delete target[tagKey];
              });
            }

            var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);

            if (legacyDispositionKeys.length) {
              target.disposition = target.disposition || {};

              legacyDispositionKeys.forEach(function(dispositionKey) {
                target.disposition[dispositionKey.substr(12)] = target[dispositionKey];
                delete target[dispositionKey];
              });
            }
          }
        });

        handleCallback(null, data);
      }
    }

    // Handle ffprobe exit
    var processExited = false;
    ffprobe.on(&#x27;exit&#x27;, function(code, signal) {
      processExited = true;

      if (code) {
        handleExit(new Error(&#x27;ffprobe exited with code &#x27; + code));
      } else if (signal) {
        handleExit(new Error(&#x27;ffprobe was killed with signal &#x27; + signal));
      } else {
        handleExit();
      }
    });

    // Handle stdout/stderr streams
    ffprobe.stdout.on(&#x27;data&#x27;, function(data) {
      stdout += data;
    });

    ffprobe.stdout.on(&#x27;clo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function runFfprobe(command) {
const inputProbeIndex = 0;
if (command._inputs[inputProbeIndex].isStream) {
  // Don&#x27;t probe input streams as this will consume them
  return;
}
command.<span class="apidocCodeKeywordSpan">ffprobe</span>(inputProbeIndex, function(err, data) {
  command._ffprobeData = data;
});
}


module.exports = function(proto) {
/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.filterGraph" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.filterGraph">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>filterGraph
        <span class="apidocSignatureSpan">(spec, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterGraph = function (spec, map) {
  this._complexFilters.clear();

  if (!Array.isArray(spec)) {
    spec = [spec];
  }

  this._complexFilters(&#x27;-filter_complex&#x27;, utils.makeFilterStrings(spec).join(&#x27;;&#x27;));

  if (Array.isArray(map)) {
    var self = this;
    map.forEach(function(streamSpec) {
      self._complexFilters(&#x27;-map&#x27;, streamSpec.replace(utils.streamRegexp, &#x27;[$1]&#x27;));
    });
  } else if (typeof map === &#x27;string&#x27;) {
    this._complexFilters(&#x27;-map&#x27;, map.replace(utils.streamRegexp, &#x27;[$1]&#x27;));
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.flvmeta" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.flvmeta">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>flvmeta
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flvmeta = function () {
  this._currentOutput.flags.flvmeta = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*jshint node:true */
&#x27;use strict&#x27;;

exports.load = function(ffmpeg) {
ffmpeg
  .format(&#x27;flv&#x27;)
  .<span class="apidocCodeKeywordSpan">flvmeta</span>()
  .size(&#x27;320x?&#x27;)
  .videoBitrate(&#x27;512k&#x27;)
  .videoCodec(&#x27;libx264&#x27;)
  .fps(24)
  .audioBitrate(&#x27;96k&#x27;)
  .audioCodec(&#x27;aac&#x27;)
  .audioFrequency(22050)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.format" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.format">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>format
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (format) {
  this._currentOutput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/*jshint node:true */
&#x27;use strict&#x27;;

exports.load = function(ffmpeg) {
ffmpeg
  .<span class="apidocCodeKeywordSpan">format</span>(&#x27;avi&#x27;)
  .videoBitrate(&#x27;1024k&#x27;)
  .videoCodec(&#x27;mpeg4&#x27;)
  .size(&#x27;720x?&#x27;)
  .audioBitrate(&#x27;128k&#x27;)
  .audioChannels(2)
  .audioCodec(&#x27;libmp3lame&#x27;)
  .outputOptions([&#x27;-vtag DIVX&#x27;]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fps" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fps">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fps
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fps = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fpsInput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fpsInput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fpsInput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fpsInput = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fpsOutput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fpsOutput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fpsOutput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fpsOutput = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.frames" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.frames">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>frames
        <span class="apidocSignatureSpan">(frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">frames = function (frames) {
  this._currentOutput.video(&#x27;-vframes&#x27;, frames);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (i === 0) {
    first = config.timemarks[i];
    self.seekInput(first);
  }

  self.output(path.join(config.folder, filenames[i]))
    .<span class="apidocCodeKeywordSpan">frames</span>(1)
    .map(stream);

  if (i &#x3e; 0) {
    self.seek(config.timemarks[i] - first);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fromFormat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.fromFormat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>fromFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromFormat = function (format) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableCodecs" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableCodecs">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableCodecs
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableCodecs = function (callback) {
  if (&#x27;codecs&#x27; in cache) {
    return callback(null, cache.codecs);
  }

  this._spawnFfmpeg([&#x27;-codecs&#x27;], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    var stdout = stdoutRing.get();
    var lines = stdout.split(lineBreakRegexp);
    var data = {};

    lines.forEach(function(line) {
      var match = line.match(avCodecRegexp);
      if (match &#x26;&#x26; match[7] !== &#x27;=&#x27;) {
        data[match[7]] = {
          type: { &#x27;V&#x27;: &#x27;video&#x27;, &#x27;A&#x27;: &#x27;audio&#x27;, &#x27;S&#x27;: &#x27;subtitle&#x27; }[match[3]],
          description: match[8],
          canDecode: match[1] === &#x27;D&#x27;,
          canEncode: match[2] === &#x27;E&#x27;,
          drawHorizBand: match[4] === &#x27;S&#x27;,
          directRendering: match[5] === &#x27;D&#x27;,
          weirdFrameTruncation: match[6] === &#x27;T&#x27;
        };
      }

      match = line.match(ffCodecRegexp);
      if (match &#x26;&#x26; match[7] !== &#x27;=&#x27;) {
        var codecData = data[match[7]] = {
          type: { &#x27;V&#x27;: &#x27;video&#x27;, &#x27;A&#x27;: &#x27;audio&#x27;, &#x27;S&#x27;: &#x27;subtitle&#x27; }[match[3]],
          description: match[8],
          canDecode: match[1] === &#x27;D&#x27;,
          canEncode: match[2] === &#x27;E&#x27;,
          intraFrameOnly: match[4] === &#x27;I&#x27;,
          isLossy: match[5] === &#x27;L&#x27;,
          isLossless: match[6] === &#x27;S&#x27;
        };

        var encoders = codecData.description.match(ffEncodersRegexp);
        encoders = encoders ? encoders[1].trim().split(&#x27; &#x27;) : [];

        var decoders = codecData.description.match(ffDecodersRegexp);
        decoders = decoders ? decoders[1].trim().split(&#x27; &#x27;) : [];

        if (encoders.length || decoders.length) {
          var coderData = {};
          utils.copy(codecData, coderData);
          delete coderData.canEncode;
          delete coderData.canDecode;

          encoders.forEach(function(name) {
            data[name] = {};
            utils.copy(coderData, data[name]);
            data[name].canEncode = true;
          });

          decoders.forEach(function(name) {
            if (name in data) {
              data[name].canDecode = true;
            } else {
              data[name] = {};
              utils.copy(coderData, data[name]);
              data[name].canDecode = true;
            }
          });
        }
      }
    });

    callback(null, cache.codecs = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableEncoders" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableEncoders">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableEncoders
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableEncoders = function (callback) {
  if (&#x27;encoders&#x27; in cache) {
    return callback(null, cache.encoders);
  }

  this._spawnFfmpeg([&#x27;-encoders&#x27;], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    var stdout = stdoutRing.get();
    var lines = stdout.split(lineBreakRegexp);
    var data = {};

    lines.forEach(function(line) {
      var match = line.match(encodersRegexp);
      if (match &#x26;&#x26; match[7] !== &#x27;=&#x27;) {
        data[match[7]] = {
          type: { &#x27;V&#x27;: &#x27;video&#x27;, &#x27;A&#x27;: &#x27;audio&#x27;, &#x27;S&#x27;: &#x27;subtitle&#x27; }[match[1]],
          description: match[8],
          frameMT: match[2] === &#x27;F&#x27;,
          sliceMT: match[3] === &#x27;S&#x27;,
          experimental: match[4] === &#x27;X&#x27;,
          drawHorizBand: match[5] === &#x27;B&#x27;,
          directRendering: match[6] === &#x27;D&#x27;
        };
      }
    });

    callback(null, cache.encoders = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableFilters
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFilters = function (callback) {
  if (&#x27;filters&#x27; in cache) {
    return callback(null, cache.filters);
  }

  this._spawnFfmpeg([&#x27;-filters&#x27;], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    var stdout = stdoutRing.get();
    var lines = stdout.split(&#x27;\n&#x27;);
    var data = {};
    var types = { A: &#x27;audio&#x27;, V: &#x27;video&#x27;, &#x27;|&#x27;: &#x27;none&#x27; };

    lines.forEach(function(line) {
      var match = line.match(filterRegexp);
      if (match) {
        data[match[1]] = {
          description: match[4],
          input: types[match[2].charAt(0)],
          multipleInputs: match[2].length &#x3e; 1,
          output: types[match[3].charAt(0)],
          multipleOutputs: match[3].length &#x3e; 1
        };
      }
    });

    callback(null, cache.filters = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableFormats" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.getAvailableFormats">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>getAvailableFormats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAvailableFormats = function (callback) {
  if (&#x27;formats&#x27; in cache) {
    return callback(null, cache.formats);
  }

  // Run ffmpeg -formats
  this._spawnFfmpeg([&#x27;-formats&#x27;], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {
    if (err) {
      return callback(err);
    }

    // Parse output
    var stdout = stdoutRing.get();
    var lines = stdout.split(lineBreakRegexp);
    var data = {};

    lines.forEach(function(line) {
      var match = line.match(formatRegexp);
      if (match) {
        match[3].split(&#x27;,&#x27;).forEach(function(format) {
          if (!(format in data)) {
            data[format] = {
              description: match[4],
              canDemux: false,
              canMux: false
            };
          }

          if (match[1] === &#x27;D&#x27;) {
            data[format].canDemux = true;
          }
          if (match[2] === &#x27;E&#x27;) {
            data[format].canMux = true;
          }
        });
      }
    });

    callback(null, cache.formats = data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.input" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.input">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>input
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">input = function (source) {
  var isFile = false;
  var isStream = false;

  if (typeof source !== &#x27;string&#x27;) {
    if (!(&#x27;readable&#x27; in source) || !(source.readable)) {
      throw new Error(&#x27;Invalid input&#x27;);
    }

    var hasInputStream = this._inputs.some(function(input) {
      return input.isStream;
    });

    if (hasInputStream) {
      throw new Error(&#x27;Only one input stream is supported&#x27;);
    }

    isStream = true;
    source.pause();
  } else {
    var protocol = source.match(/^([a-z]{2,}):/i);
    isFile = !protocol || protocol[0] === &#x27;file&#x27;;
  }

  this._inputs.push(this._currentInput = {
    source: source,
    isFile: isFile,
    isStream: isStream,
    options: utils.args()
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Specify a complex filtergraph
*
* Calling this method will override any previously set filtergraph, but you can set
* as many filters as needed in one call.
*
* @example &#x3c;caption&#x3e;Overlay an image over a video (using a filtergraph string)&#x3c;/caption&#x3e;
*   ffmpeg()
*     .<span class="apidocCodeKeywordSpan">input</span>(&#x27;video.avi&#x27;)
*     .input(&#x27;image.png&#x27;)
*     .complexFilter(&#x27;[0:v][1:v]overlay[out]&#x27;, [&#x27;out&#x27;]);
*
* @example &#x3c;caption&#x3e;Overlay an image over a video (using a filter array)&#x3c;/caption&#x3e;
*   ffmpeg()
*     .input(&#x27;video.avi&#x27;)
*     .input(&#x27;image.png&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFPS" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFPS">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputFPS
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inputFPS = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFormat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFormat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inputFormat = function (format) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFps" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputFps">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputFps
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inputFps = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inputOption = function (options) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentInput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.inputOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>inputOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inputOptions = function (options) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentInput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* When passing a single string or an array, each string containing two
* words is split (eg. inputOptions(&#x27;-option value&#x27;) is supported) for
* compatibility reasons.  This is not the case when passing more than
* one argument.
*
* @example
* command.<span class="apidocCodeKeywordSpan">inputOptions</span>(&#x27;option1&#x27;);
*
* @example
* command.inputOptions(&#x27;option1&#x27;, &#x27;option2&#x27;);
*
* @example
* command.inputOptions([&#x27;option1&#x27;, &#x27;option2&#x27;]);
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDAR" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDAR">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepDAR
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keepDAR = function () {
  return this.videoFilters([
    {
      filter: &#x27;scale&#x27;,
      options: {
        w: &#x27;if(gt(sar,1),iw*sar,iw)&#x27;,
        h: &#x27;if(lt(sar,1),ih/sar,ih)&#x27;
      }
    },
    {
      filter: &#x27;setsar&#x27;,
      options: &#x27;1&#x27;
    }
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDisplayAspect" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDisplayAspect">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepDisplayAspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keepDisplayAspect = function () {
  return this.videoFilters([
    {
      filter: &#x27;scale&#x27;,
      options: {
        w: &#x27;if(gt(sar,1),iw*sar,iw)&#x27;,
        h: &#x27;if(lt(sar,1),ih/sar,ih)&#x27;
      }
    },
    {
      filter: &#x27;setsar&#x27;,
      options: &#x27;1&#x27;
    }
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDisplayAspectRatio" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepDisplayAspectRatio">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepDisplayAspectRatio
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keepDisplayAspectRatio = function () {
  return this.videoFilters([
    {
      filter: &#x27;scale&#x27;,
      options: {
        w: &#x27;if(gt(sar,1),iw*sar,iw)&#x27;,
        h: &#x27;if(lt(sar,1),ih/sar,ih)&#x27;
      }
    },
    {
      filter: &#x27;setsar&#x27;,
      options: &#x27;1&#x27;
    }
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepPixelAspect" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.keepPixelAspect">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>keepPixelAspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keepPixelAspect = function () {
  return this.videoFilters([
    {
      filter: &#x27;scale&#x27;,
      options: {
        w: &#x27;if(gt(sar,1),iw*sar,iw)&#x27;,
        h: &#x27;if(lt(sar,1),ih/sar,ih)&#x27;
      }
    },
    {
      filter: &#x27;setsar&#x27;,
      options: &#x27;1&#x27;
    }
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.kill" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.kill">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>kill
        <span class="apidocSignatureSpan">(signal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (signal) {
  if (!this.ffmpegProc) {
    this.logger.warn(&#x27;No running ffmpeg process, cannot send signal&#x27;);
  } else {
    this.ffmpegProc.kill(signal || &#x27;SIGKILL&#x27;);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

          // Pipe input stream if any
          if (inputStream) {
inputStream.source.on(&#x27;error&#x27;, function(err) {
  var reportingErr = new Error(&#x27;Input stream error: &#x27; + err.message);
  reportingErr.inputStreamError = err;
  emitEnd(reportingErr);
  ffmpegProc.<span class="apidocCodeKeywordSpan">kill</span>();
});

inputStream.source.resume();
inputStream.source.pipe(ffmpegProc.stdin);

// Set stdin error handler on ffmpeg (prevents nodejs catching the error, but
// ffmpeg will fail anyway, so no need to actually handle anything)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.loop" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.loop">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>loop
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loop = function (duration) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-loop&#x27;, &#x27;1&#x27;);

  if (typeof duration !== &#x27;undefined&#x27;) {
    this.duration(duration);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.map" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.map">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>map
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (spec) {
  this._currentOutput.options(&#x27;-map&#x27;, spec.replace(utils.streamRegexp, &#x27;[$1]&#x27;));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  duration = Number(meta.format.duration);
}

if (isNaN(duration)) {
  return next(new Error(&#x27;Could not get input duration, please specify fixed timemarks&#x27;));
}

config.timemarks = config.timemarks.<span class="apidocCodeKeywordSpan">map</span>(function(mark) {
  if ((&#x27;&#x27; + mark).match(/^([\d.]+)%$/)) {
    return duration * parseFloat(mark) / 100;
  } else {
    return mark;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.mergeAdd" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.mergeAdd">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>mergeAdd
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeAdd = function (source) {
  var isFile = false;
  var isStream = false;

  if (typeof source !== &#x27;string&#x27;) {
    if (!(&#x27;readable&#x27; in source) || !(source.readable)) {
      throw new Error(&#x27;Invalid input&#x27;);
    }

    var hasInputStream = this._inputs.some(function(input) {
      return input.isStream;
    });

    if (hasInputStream) {
      throw new Error(&#x27;Only one input stream is supported&#x27;);
    }

    isStream = true;
    source.pause();
  } else {
    var protocol = source.match(/^([a-z]{2,}):/i);
    isFile = !protocol || protocol[0] === &#x27;file&#x27;;
  }

  this._inputs.push(this._currentInput = {
    source: source,
    isFile: isFile,
    isStream: isStream,
    options: utils.args()
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.mergeToFile" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.mergeToFile">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>mergeToFile
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeToFile = function (target, options) {
  // Find out which streams are present in the first non-stream input
  var fileInput = this._inputs.filter(function(input) {
    return !input.isStream;
  })[0];

  var self = this;
  this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {
    if (err) {
      return self.emit(&#x27;error&#x27;, err);
    }

    var hasAudioStreams = data.streams.some(function(stream) {
      return stream.codec_type === &#x27;audio&#x27;;
    });

    var hasVideoStreams = data.streams.some(function(stream) {
      return stream.codec_type === &#x27;video&#x27;;
    });

    // Setup concat filter and start processing
    self.output(target, options)
      .complexFilter({
        filter: &#x27;concat&#x27;,
        options: {
          n: self._inputs.length,
          v: hasVideoStreams ? 1 : 0,
          a: hasAudioStreams ? 1 : 0
        }
      })
      .run();
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.native" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.native">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>native
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">native = function () {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-re&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.nativeFramerate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.nativeFramerate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>nativeFramerate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeFramerate = function () {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-re&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.noAudio" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.noAudio">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>noAudio
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noAudio = function () {
  this._currentOutput.audio.clear();
  this._currentOutput.audioFilters.clear();
  this._currentOutput.audio(&#x27;-an&#x27;);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.noVideo" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.noVideo">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>noVideo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noVideo = function () {
  this._currentOutput.video.clear();
  this._currentOutput.videoFilters.clear();
  this._currentOutput.video(&#x27;-vn&#x27;);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.output" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.output">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>output
        <span class="apidocSignatureSpan">(target, pipeopts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">output = function (target, pipeopts) {
  var isFile = false;

  if (!target &#x26;&#x26; this._currentOutput) {
    // No target is only allowed when called from constructor
    throw new Error(&#x27;Invalid output&#x27;);
  }

  if (target &#x26;&#x26; typeof target !== &#x27;string&#x27;) {
    if (!(&#x27;writable&#x27; in target) || !(target.writable)) {
      throw new Error(&#x27;Invalid output&#x27;);
    }
  } else if (typeof target === &#x27;string&#x27;) {
    var protocol = target.match(/^([a-z]{2,}):/i);
    isFile = !protocol || protocol[0] === &#x27;file&#x27;;
  }

  if (target &#x26;&#x26; !(&#x27;target&#x27; in this._currentOutput)) {
    // For backwards compatibility, set target for first output
    this._currentOutput.target = target;
    this._currentOutput.isFile = isFile;
    this._currentOutput.pipeopts = pipeopts || {};
  } else {
    if (target &#x26;&#x26; typeof target !== &#x27;string&#x27;) {
      var hasOutputStream = this._outputs.some(function(output) {
        return typeof output.target !== &#x27;string&#x27;;
      });

      if (hasOutputStream) {
        throw new Error(&#x27;Only one output stream is supported&#x27;);
      }
    }

    this._outputs.push(this._currentOutput = {
      target: target,
      isFile: isFile,
      flags: {},
      pipeopts: pipeopts || {}
    });

    var self = this;
    [&#x27;audio&#x27;, &#x27;audioFilters&#x27;, &#x27;video&#x27;, &#x27;videoFilters&#x27;, &#x27;sizeFilters&#x27;, &#x27;options&#x27;].forEach(function(key) {
      self._currentOutput[key] = utils.args();
    });

    if (!target) {
      // Call from constructor: remove target key
      delete this._currentOutput.target;
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @aliases saveToFile
 *
 * @param {String} output file path
 * @return FfmpegCommand
 */
proto.saveToFile =
proto.save = function(output) {
  this.<span class="apidocCodeKeywordSpan">output</span>(output).run();
  return this;
};


/**
 * Execute ffmpeg command and save output to a stream
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFPS" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFPS">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputFPS
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputFPS = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFormat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFormat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputFormat = function (format) {
  this._currentOutput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFps" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputFps">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputFps
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputFps = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputOption = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.outputOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>outputOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputOptions = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};


/**
 * Add custom output option(s)
 *
 * @example
 * command.<span class="apidocCodeKeywordSpan">outputOptions</span>(&#x27;option1&#x27;);
 *
 * @example
 * command.outputOptions(&#x27;option1&#x27;, &#x27;option2&#x27;);
 *
 * @example
 * command.outputOptions([&#x27;option1&#x27;, &#x27;option2&#x27;]);
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.pipe" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.pipe">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>pipe
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (stream, options) {
  if (stream &#x26;&#x26; !(&#x27;writable&#x27; in stream)) {
    options = stream;
    stream = undefined;
  }

  if (!stream) {
    if (process.version.match(/v0\.8\./)) {
      throw new Error(&#x27;PassThrough stream is not supported on node v0.8&#x27;);
    }

    stream = new PassThrough();
  }

  this.output(stream, options).run();
  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Once ffprobe&#x27;s input stream closes, we need no more data from the
  // input
  ffprobe.stdin.on(&#x27;close&#x27;, function() {
      input.source.pause();
      input.source.unpipe(ffprobe.stdin);
  });

  input.source.<span class="apidocCodeKeywordSpan">pipe</span>(ffprobe.stdin);
}

ffprobe.on(&#x27;error&#x27;, callback);

// Ensure we wait for captured streams to end before calling callback
var exitError = null;
function handleExit(err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.preset" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.preset">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>preset
        <span class="apidocSignatureSpan">(preset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">preset = function (preset) {
  if (typeof preset === &#x27;function&#x27;) {
    preset(this);
  } else {
    try {
      var modulePath = path.join(this.options.presets, preset);
      var module = require(modulePath);

      if (typeof module.load === &#x27;function&#x27;) {
        module.load(this);
      } else {
        throw new Error(&#x27;preset &#x27; + modulePath + &#x27; has no load() function&#x27;);
      }
    } catch (err) {
      throw new Error(&#x27;preset &#x27; + modulePath + &#x27; could not be loaded: &#x27; + err.message);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.renice" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.renice">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>renice
        <span class="apidocSignatureSpan">(niceness)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renice = function (niceness) {
  if (!utils.isWindows) {
    niceness = niceness || 0;

    if (niceness &#x3c; -20 || niceness &#x3e; 20) {
      this.logger.warn(&#x27;Invalid niceness value: &#x27; + niceness + &#x27;, must be between -20 and 20&#x27;);
    }

    niceness = Math.min(20, Math.max(-20, niceness));
    this.options.niceness = niceness;

    if (this.ffmpegProc) {
      var logger = this.logger;
      var pid = this.ffmpegProc.pid;
      var renice = spawn(&#x27;renice&#x27;, [niceness, &#x27;-p&#x27;, pid]);

      renice.on(&#x27;error&#x27;, function(err) {
        logger.warn(&#x27;could not renice process &#x27; + pid + &#x27;: &#x27; + err.message);
      });

      renice.on(&#x27;exit&#x27;, function(code, signal) {
        if (signal) {
          logger.warn(&#x27;could not renice process &#x27; + pid + &#x27;: renice was killed by signal &#x27; + signal);
        } else if (code) {
          logger.warn(&#x27;could not renice process &#x27; + pid + &#x27;: renice exited with &#x27; + code);
        } else {
          logger.info(&#x27;successfully reniced process &#x27; + pid + &#x27; to &#x27; + niceness + &#x27; niceness&#x27;);
        }
      });
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.run" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.run">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>run
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function () {
  var self = this;

  // Check if at least one output is present
  var outputPresent = this._outputs.some(function(output) {
    return &#x27;target&#x27; in output;
  });

  if (!outputPresent) {
    throw new Error(&#x27;No output specified&#x27;);
  }

  // Get output stream if any
  var outputStream = this._outputs.filter(function(output) {
    return typeof output.target !== &#x27;string&#x27;;
  })[0];

  // Get input stream if any
  var inputStream = this._inputs.filter(function(input) {
    return typeof input.source !== &#x27;string&#x27;;
  })[0];

  // Ensure we send &#x27;end&#x27; or &#x27;error&#x27; only once
  var ended = false;
  function emitEnd(err, stdout, stderr) {
    if (!ended) {
      ended = true;

      if (err) {
        self.emit(&#x27;error&#x27;, err, stdout, stderr);
      } else {
        self.emit(&#x27;end&#x27;, stdout, stderr);
      }
    }
  }

  self._prepare(function(err, args) {
    if (err) {
      return emitEnd(err);
    }

    // Run ffmpeg
    self._spawnFfmpeg(
      args,
      {
        captureStdout: !outputStream,
        niceness: self.options.niceness,
        cwd: self.options.cwd
      },

      function processCB(ffmpegProc, stdoutRing, stderrRing) {
        self.ffmpegProc = ffmpegProc;
        self.emit(&#x27;start&#x27;, &#x27;ffmpeg &#x27; + args.join(&#x27; &#x27;));

        // Pipe input stream if any
        if (inputStream) {
          inputStream.source.on(&#x27;error&#x27;, function(err) {
            var reportingErr = new Error(&#x27;Input stream error: &#x27; + err.message);
            reportingErr.inputStreamError = err;
            emitEnd(reportingErr);
            ffmpegProc.kill();
          });

          inputStream.source.resume();
          inputStream.source.pipe(ffmpegProc.stdin);

          // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but
          // ffmpeg will fail anyway, so no need to actually handle anything)
          ffmpegProc.stdin.on(&#x27;error&#x27;, function() {});
        }

        // Setup timeout if requested
        var processTimer;
        if (self.options.timeout) {
          processTimer = setTimeout(function() {
            var msg = &#x27;process ran into a timeout (&#x27; + self.options.timeout + &#x27;s)&#x27;;

            emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());
            ffmpegProc.kill();
          }, self.options.timeout * 1000);
        }


        if (outputStream) {
          // Pipe ffmpeg stdout to output stream
          ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);

          // Handle output stream events
          outputStream.target.on(&#x27;close&#x27;, function() {
            self.logger.debug(&#x27;Output stream closed, scheduling kill for ffmpeg process&#x27;);

            // Don&#x27;t kill process yet, to give a chance to ffmpeg to
            // terminate successfully first  This is necessary because
            // under load, the process &#x27;exit&#x27; event sometimes happens
            // after the output stream &#x27;close&#x27; event.
            setTimeout(function() {
              emitEnd(new Error(&#x27;Output stream closed&#x27;));
              ffmpegProc.kill();
            }, 20);
          });

          outputStream.target.on(&#x27;error&#x27;, function(err) {
            self.logger.debug(&#x27;Output stream error, killing ffmpeg process&#x27;);
            var reportingErr = new Error(&#x27;Output stream error: &#x27; + err.message);
            reportingErr.outputStreamError = err;
            emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());
            ffmpegProc.kill(&#x27;SIGKILL&#x27;);
          });
        }

        // Setup stderr handling
        if (stderrRing) {

          // &#x27;stderr&#x27; event
          if (self.listeners(&#x27;stderr&#x27;).length) {
            stderrRing.callback(function(line) {
              self.emit(&#x27;stderr&#x27;, line);
            });
          }

          // &#x27;codecData&#x27; event
          if (self.listeners(&#x27;codecData&#x27;).length) {
            var codecDataSent = false;
            var codecObject = {};

            stderrRing.callback(function(line) {
              if (!codecDataSent)
                codecDataSent = utils.extractCodecData(self, line, codecObject);
            });
          }

          // &#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @aliases saveToFile
 *
 * @param {String} output file path
 * @return FfmpegCommand
 */
proto.saveToFile =
proto.save = function(output) {
  this.output(output).<span class="apidocCodeKeywordSpan">run</span>();
  return this;
};


/**
 * Execute ffmpeg command and save output to a stream
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.save" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.save">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>save
        <span class="apidocSignatureSpan">(output)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function (output) {
  this.output(output).run();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.saveToFile" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.saveToFile">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>saveToFile
        <span class="apidocSignatureSpan">(output)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveToFile = function (output) {
  this.output(output).run();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.screenshot" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.screenshot">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>screenshot
        <span class="apidocSignatureSpan">(config, folder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">screenshot = function (config, folder) {
  var self = this;
  var source = this._currentInput.source;
  config = config || { count: 1 };

  // Accept a number of screenshots instead of a config object
  if (typeof config === &#x27;number&#x27;) {
    config = {
      count: config
    };
  }

  // Accept a second &#x27;folder&#x27; parameter instead of config.folder
  if (!(&#x27;folder&#x27; in config)) {
    config.folder = folder || &#x27;.&#x27;;
  }

  // Accept &#x27;timestamps&#x27; instead of &#x27;timemarks&#x27;
  if (&#x27;timestamps&#x27; in config) {
    config.timemarks = config.timestamps;
  }

  // Compute timemarks from count if not present
  if (!(&#x27;timemarks&#x27; in config)) {
    if (!config.count) {
      throw new Error(&#x27;Cannot take screenshots: neither a count nor a timemark list are specified&#x27;);
    }

    var interval = 100 / (1 + config.count);
    config.timemarks = [];
    for (var i = 0; i &#x3c; config.count; i++) {
      config.timemarks.push((interval * (i + 1)) + &#x27;%&#x27;);
    }
  }

  // Parse size option
  if (&#x27;size&#x27; in config) {
    var fixedSize = config.size.match(/^(\d+)x(\d+)$/);
    var fixedWidth = config.size.match(/^(\d+)x\?$/);
    var fixedHeight = config.size.match(/^\?x(\d+)$/);
    var percentSize = config.size.match(/^(\d+)%$/);

    if (!fixedSize &#x26;&#x26; !fixedWidth &#x26;&#x26; !fixedHeight &#x26;&#x26; !percentSize) {
      throw new Error(&#x27;Invalid size parameter: &#x27; + config.size);
    }
  }

  // Metadata helper
  var metadata;
  function getMetadata(cb) {
    if (metadata) {
      cb(null, metadata);
    } else {
      self.ffprobe(function(err, meta) {
        metadata = meta;
        cb(err, meta);
      });
    }
  }

  async.waterfall([
    // Compute percent timemarks if any
    function computeTimemarks(next) {
      if (config.timemarks.some(function(t) { return (&#x27;&#x27; + t).match(/^[\d.]+%$/); })) {
        if (typeof source !== &#x27;string&#x27;) {
          return next(new Error(&#x27;Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks&#x27;));
        }

        getMetadata(function(err, meta) {
          if (err) {
            next(err);
          } else {
            // Select video stream with the highest resolution
            var vstream = meta.streams.reduce(function(biggest, stream) {
              if (stream.codec_type === &#x27;video&#x27; &#x26;&#x26; stream.width * stream.height &#x3e; biggest.width * biggest.height) {
                return stream;
              } else {
                return biggest;
              }
            }, { width: 0, height: 0 });

            if (vstream.width === 0) {
              return next(new Error(&#x27;No video stream in input, cannot take screenshots&#x27;));
            }

            var duration = Number(vstream.duration);
            if (isNaN(duration)) {
              duration = Number(meta.format.duration);
            }

            if (isNaN(duration)) {
              return next(new Error(&#x27;Could not get input duration, please specify fixed timemarks&#x27;));
            }

            config.timemarks = config.timemarks.map(function(mark) {
              if ((&#x27;&#x27; + mark).match(/^([\d.]+)%$/)) {
                return duration * parseFloat(mark) / 100;
              } else {
                return mark;
              }
            });

            next();
          }
        });
      } else {
        next();
      }
    },

    // Turn all timemarks into numbers and sort them
    function normalizeTimemarks(next) {
      config.timemarks = config.timemarks.map(function(mark) {
        return utils.timemarkToSeconds(mark);
      }).sort(function(a, b) { return a - b; });

      next();
    },

    // Add &#x27;_%i&#x27; to pattern when requesting multiple screenshots and no variable token is present
    function fixPattern(next) {
      var pattern = config.filename || &#x27;tn.png&#x27;;

      if (pattern.indexOf(&#x27;.&#x27;) === -1) {
        pattern += &#x27;.png&#x27;;
      }

      if (config.timemarks.length &#x3e; 1 &#x26;&#x26; !pattern.match(/%(s|0*i)/)) {
        var ext = path.extname(pattern);
        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + &#x27;_%i&#x27; + ext);
      }

      next(null, pattern);
    },

    // Replace filename tokens (%f, %b) in pattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.screenshots" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.screenshots">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>screenshots
        <span class="apidocSignatureSpan">(config, folder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">screenshots = function (config, folder) {
  var self = this;
  var source = this._currentInput.source;
  config = config || { count: 1 };

  // Accept a number of screenshots instead of a config object
  if (typeof config === &#x27;number&#x27;) {
    config = {
      count: config
    };
  }

  // Accept a second &#x27;folder&#x27; parameter instead of config.folder
  if (!(&#x27;folder&#x27; in config)) {
    config.folder = folder || &#x27;.&#x27;;
  }

  // Accept &#x27;timestamps&#x27; instead of &#x27;timemarks&#x27;
  if (&#x27;timestamps&#x27; in config) {
    config.timemarks = config.timestamps;
  }

  // Compute timemarks from count if not present
  if (!(&#x27;timemarks&#x27; in config)) {
    if (!config.count) {
      throw new Error(&#x27;Cannot take screenshots: neither a count nor a timemark list are specified&#x27;);
    }

    var interval = 100 / (1 + config.count);
    config.timemarks = [];
    for (var i = 0; i &#x3c; config.count; i++) {
      config.timemarks.push((interval * (i + 1)) + &#x27;%&#x27;);
    }
  }

  // Parse size option
  if (&#x27;size&#x27; in config) {
    var fixedSize = config.size.match(/^(\d+)x(\d+)$/);
    var fixedWidth = config.size.match(/^(\d+)x\?$/);
    var fixedHeight = config.size.match(/^\?x(\d+)$/);
    var percentSize = config.size.match(/^(\d+)%$/);

    if (!fixedSize &#x26;&#x26; !fixedWidth &#x26;&#x26; !fixedHeight &#x26;&#x26; !percentSize) {
      throw new Error(&#x27;Invalid size parameter: &#x27; + config.size);
    }
  }

  // Metadata helper
  var metadata;
  function getMetadata(cb) {
    if (metadata) {
      cb(null, metadata);
    } else {
      self.ffprobe(function(err, meta) {
        metadata = meta;
        cb(err, meta);
      });
    }
  }

  async.waterfall([
    // Compute percent timemarks if any
    function computeTimemarks(next) {
      if (config.timemarks.some(function(t) { return (&#x27;&#x27; + t).match(/^[\d.]+%$/); })) {
        if (typeof source !== &#x27;string&#x27;) {
          return next(new Error(&#x27;Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks&#x27;));
        }

        getMetadata(function(err, meta) {
          if (err) {
            next(err);
          } else {
            // Select video stream with the highest resolution
            var vstream = meta.streams.reduce(function(biggest, stream) {
              if (stream.codec_type === &#x27;video&#x27; &#x26;&#x26; stream.width * stream.height &#x3e; biggest.width * biggest.height) {
                return stream;
              } else {
                return biggest;
              }
            }, { width: 0, height: 0 });

            if (vstream.width === 0) {
              return next(new Error(&#x27;No video stream in input, cannot take screenshots&#x27;));
            }

            var duration = Number(vstream.duration);
            if (isNaN(duration)) {
              duration = Number(meta.format.duration);
            }

            if (isNaN(duration)) {
              return next(new Error(&#x27;Could not get input duration, please specify fixed timemarks&#x27;));
            }

            config.timemarks = config.timemarks.map(function(mark) {
              if ((&#x27;&#x27; + mark).match(/^([\d.]+)%$/)) {
                return duration * parseFloat(mark) / 100;
              } else {
                return mark;
              }
            });

            next();
          }
        });
      } else {
        next();
      }
    },

    // Turn all timemarks into numbers and sort them
    function normalizeTimemarks(next) {
      config.timemarks = config.timemarks.map(function(mark) {
        return utils.timemarkToSeconds(mark);
      }).sort(function(a, b) { return a - b; });

      next();
    },

    // Add &#x27;_%i&#x27; to pattern when requesting multiple screenshots and no variable token is present
    function fixPattern(next) {
      var pattern = config.filename || &#x27;tn.png&#x27;;

      if (pattern.indexOf(&#x27;.&#x27;) === -1) {
        pattern += &#x27;.png&#x27;;
      }

      if (config.timemarks.length &#x3e; 1 &#x26;&#x26; !pattern.match(/%(s|0*i)/)) {
        var ext = path.extname(pattern);
        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + &#x27;_%i&#x27; + ext);
      }

      next(null, pattern);
    },

    // Replace filename tokens (%f, %b) in pattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seek" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seek">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>seek
        <span class="apidocSignatureSpan">(seek)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seek = function (seek) {
  this._currentOutput.options(&#x27;-ss&#x27;, seek);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    self.output(path.join(config.folder, filenames[i]))
      .frames(1)
      .map(stream);

    if (i &#x3e; 0) {
      self.<span class="apidocCodeKeywordSpan">seek</span>(config.timemarks[i] - first);
    }
  }

  self.complexFilter(filters);
  self.run();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seekInput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seekInput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>seekInput
        <span class="apidocSignatureSpan">(seek)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seekInput = function (seek) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-ss&#x27;, seek);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var first = 0;
      for (var i = 0; i &#x3c; count; i++) {
var stream = &#x27;screen&#x27; + i;
split.outputs.push(stream);

if (i === 0) {
  first = config.timemarks[i];
  self.<span class="apidocCodeKeywordSpan">seekInput</span>(first);
}

self.output(path.join(config.folder, filenames[i]))
  .frames(1)
  .map(stream);

if (i &#x3e; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seekOutput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.seekOutput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>seekOutput
        <span class="apidocSignatureSpan">(seek)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seekOutput = function (seek) {
  this._currentOutput.options(&#x27;-ss&#x27;, seek);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setAspect" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setAspect">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setAspect
        <span class="apidocSignatureSpan">(aspect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAspect = function (aspect) {
  var a = Number(aspect);
  if (isNaN(a)) {
    var match = aspect.match(/^(\d+):(\d+)$/);
    if (match) {
      a = Number(match[1]) / Number(match[2]);
    } else {
      throw new Error(&#x27;Invalid aspect ratio: &#x27; + aspect);
    }
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;aspect&#x27;, a);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setAspectRatio" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setAspectRatio">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setAspectRatio
        <span class="apidocSignatureSpan">(aspect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setAspectRatio = function (aspect) {
  var a = Number(aspect);
  if (isNaN(a)) {
    var match = aspect.match(/^(\d+):(\d+)$/);
    if (match) {
      a = Number(match[1]) / Number(match[2]);
    } else {
      throw new Error(&#x27;Invalid aspect ratio: &#x27; + aspect);
    }
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;aspect&#x27;, a);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setDuration" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setDuration">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setDuration
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDuration = function (duration) {
  this._currentOutput.options(&#x27;-t&#x27;, duration);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFfmpegPath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFfmpegPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setFfmpegPath
        <span class="apidocSignatureSpan">(ffmpegPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfmpegPath = function (ffmpegPath) {
  cache.ffmpegPath = ffmpegPath;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFfprobePath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFfprobePath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setFfprobePath
        <span class="apidocSignatureSpan">(ffprobePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFfprobePath = function (ffprobePath) {
  cache.ffprobePath = ffprobePath;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFlvtoolPath" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setFlvtoolPath">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setFlvtoolPath
        <span class="apidocSignatureSpan">(flvtool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFlvtoolPath = function (flvtool) {
  cache.flvtoolPath = flvtool;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setSize" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setSize">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setSize
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSize = function (size) {
  var filters = createSizeFilters(this._currentOutput, &#x27;size&#x27;, size);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setStartTime" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.setStartTime">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>setStartTime
        <span class="apidocSignatureSpan">(seek)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setStartTime = function (seek) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-ss&#x27;, seek);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.size" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.size">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>size
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function (size) {
  var filters = createSizeFilters(this._currentOutput, &#x27;size&#x27;, size);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
filter: &#x27;split&#x27;,
options: count,
outputs: []
      }];

      if (&#x27;size&#x27; in config) {
// Set size to generate size filters
self.<span class="apidocCodeKeywordSpan">size</span>(config.size);

// Get size filters and chain them with &#x27;sizeN&#x27; stream names
var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {
  if (i &#x3e; 0) {
    f.inputs = &#x27;size&#x27; + (i - 1);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.stream" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.stream">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>stream
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stream = function (stream, options) {
  if (stream &#x26;&#x26; !(&#x27;writable&#x27; in stream)) {
    options = stream;
    stream = undefined;
  }

  if (!stream) {
    if (process.version.match(/v0\.8\./)) {
      throw new Error(&#x27;PassThrough stream is not supported on node v0.8&#x27;);
    }

    stream = new PassThrough();
  }

  this.output(stream, options).run();
  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.takeFrames" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.takeFrames">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>takeFrames
        <span class="apidocSignatureSpan">(frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeFrames = function (frames) {
  this._currentOutput.video(&#x27;-vframes&#x27;, frames);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.takeScreenshots" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.takeScreenshots">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>takeScreenshots
        <span class="apidocSignatureSpan">(config, folder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeScreenshots = function (config, folder) {
  var self = this;
  var source = this._currentInput.source;
  config = config || { count: 1 };

  // Accept a number of screenshots instead of a config object
  if (typeof config === &#x27;number&#x27;) {
    config = {
      count: config
    };
  }

  // Accept a second &#x27;folder&#x27; parameter instead of config.folder
  if (!(&#x27;folder&#x27; in config)) {
    config.folder = folder || &#x27;.&#x27;;
  }

  // Accept &#x27;timestamps&#x27; instead of &#x27;timemarks&#x27;
  if (&#x27;timestamps&#x27; in config) {
    config.timemarks = config.timestamps;
  }

  // Compute timemarks from count if not present
  if (!(&#x27;timemarks&#x27; in config)) {
    if (!config.count) {
      throw new Error(&#x27;Cannot take screenshots: neither a count nor a timemark list are specified&#x27;);
    }

    var interval = 100 / (1 + config.count);
    config.timemarks = [];
    for (var i = 0; i &#x3c; config.count; i++) {
      config.timemarks.push((interval * (i + 1)) + &#x27;%&#x27;);
    }
  }

  // Parse size option
  if (&#x27;size&#x27; in config) {
    var fixedSize = config.size.match(/^(\d+)x(\d+)$/);
    var fixedWidth = config.size.match(/^(\d+)x\?$/);
    var fixedHeight = config.size.match(/^\?x(\d+)$/);
    var percentSize = config.size.match(/^(\d+)%$/);

    if (!fixedSize &#x26;&#x26; !fixedWidth &#x26;&#x26; !fixedHeight &#x26;&#x26; !percentSize) {
      throw new Error(&#x27;Invalid size parameter: &#x27; + config.size);
    }
  }

  // Metadata helper
  var metadata;
  function getMetadata(cb) {
    if (metadata) {
      cb(null, metadata);
    } else {
      self.ffprobe(function(err, meta) {
        metadata = meta;
        cb(err, meta);
      });
    }
  }

  async.waterfall([
    // Compute percent timemarks if any
    function computeTimemarks(next) {
      if (config.timemarks.some(function(t) { return (&#x27;&#x27; + t).match(/^[\d.]+%$/); })) {
        if (typeof source !== &#x27;string&#x27;) {
          return next(new Error(&#x27;Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks&#x27;));
        }

        getMetadata(function(err, meta) {
          if (err) {
            next(err);
          } else {
            // Select video stream with the highest resolution
            var vstream = meta.streams.reduce(function(biggest, stream) {
              if (stream.codec_type === &#x27;video&#x27; &#x26;&#x26; stream.width * stream.height &#x3e; biggest.width * biggest.height) {
                return stream;
              } else {
                return biggest;
              }
            }, { width: 0, height: 0 });

            if (vstream.width === 0) {
              return next(new Error(&#x27;No video stream in input, cannot take screenshots&#x27;));
            }

            var duration = Number(vstream.duration);
            if (isNaN(duration)) {
              duration = Number(meta.format.duration);
            }

            if (isNaN(duration)) {
              return next(new Error(&#x27;Could not get input duration, please specify fixed timemarks&#x27;));
            }

            config.timemarks = config.timemarks.map(function(mark) {
              if ((&#x27;&#x27; + mark).match(/^([\d.]+)%$/)) {
                return duration * parseFloat(mark) / 100;
              } else {
                return mark;
              }
            });

            next();
          }
        });
      } else {
        next();
      }
    },

    // Turn all timemarks into numbers and sort them
    function normalizeTimemarks(next) {
      config.timemarks = config.timemarks.map(function(mark) {
        return utils.timemarkToSeconds(mark);
      }).sort(function(a, b) { return a - b; });

      next();
    },

    // Add &#x27;_%i&#x27; to pattern when requesting multiple screenshots and no variable token is present
    function fixPattern(next) {
      var pattern = config.filename || &#x27;tn.png&#x27;;

      if (pattern.indexOf(&#x27;.&#x27;) === -1) {
        pattern += &#x27;.png&#x27;;
      }

      if (config.timemarks.length &#x3e; 1 &#x26;&#x26; !pattern.match(/%(s|0*i)/)) {
        var ext = path.extname(pattern);
        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + &#x27;_%i&#x27; + ext);
      }

      next(null, pattern);
    },

    // Replace filename tokens (%f, %b) in pattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.thumbnail" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.thumbnail">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>thumbnail
        <span class="apidocSignatureSpan">(config, folder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thumbnail = function (config, folder) {
  var self = this;
  var source = this._currentInput.source;
  config = config || { count: 1 };

  // Accept a number of screenshots instead of a config object
  if (typeof config === &#x27;number&#x27;) {
    config = {
      count: config
    };
  }

  // Accept a second &#x27;folder&#x27; parameter instead of config.folder
  if (!(&#x27;folder&#x27; in config)) {
    config.folder = folder || &#x27;.&#x27;;
  }

  // Accept &#x27;timestamps&#x27; instead of &#x27;timemarks&#x27;
  if (&#x27;timestamps&#x27; in config) {
    config.timemarks = config.timestamps;
  }

  // Compute timemarks from count if not present
  if (!(&#x27;timemarks&#x27; in config)) {
    if (!config.count) {
      throw new Error(&#x27;Cannot take screenshots: neither a count nor a timemark list are specified&#x27;);
    }

    var interval = 100 / (1 + config.count);
    config.timemarks = [];
    for (var i = 0; i &#x3c; config.count; i++) {
      config.timemarks.push((interval * (i + 1)) + &#x27;%&#x27;);
    }
  }

  // Parse size option
  if (&#x27;size&#x27; in config) {
    var fixedSize = config.size.match(/^(\d+)x(\d+)$/);
    var fixedWidth = config.size.match(/^(\d+)x\?$/);
    var fixedHeight = config.size.match(/^\?x(\d+)$/);
    var percentSize = config.size.match(/^(\d+)%$/);

    if (!fixedSize &#x26;&#x26; !fixedWidth &#x26;&#x26; !fixedHeight &#x26;&#x26; !percentSize) {
      throw new Error(&#x27;Invalid size parameter: &#x27; + config.size);
    }
  }

  // Metadata helper
  var metadata;
  function getMetadata(cb) {
    if (metadata) {
      cb(null, metadata);
    } else {
      self.ffprobe(function(err, meta) {
        metadata = meta;
        cb(err, meta);
      });
    }
  }

  async.waterfall([
    // Compute percent timemarks if any
    function computeTimemarks(next) {
      if (config.timemarks.some(function(t) { return (&#x27;&#x27; + t).match(/^[\d.]+%$/); })) {
        if (typeof source !== &#x27;string&#x27;) {
          return next(new Error(&#x27;Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks&#x27;));
        }

        getMetadata(function(err, meta) {
          if (err) {
            next(err);
          } else {
            // Select video stream with the highest resolution
            var vstream = meta.streams.reduce(function(biggest, stream) {
              if (stream.codec_type === &#x27;video&#x27; &#x26;&#x26; stream.width * stream.height &#x3e; biggest.width * biggest.height) {
                return stream;
              } else {
                return biggest;
              }
            }, { width: 0, height: 0 });

            if (vstream.width === 0) {
              return next(new Error(&#x27;No video stream in input, cannot take screenshots&#x27;));
            }

            var duration = Number(vstream.duration);
            if (isNaN(duration)) {
              duration = Number(meta.format.duration);
            }

            if (isNaN(duration)) {
              return next(new Error(&#x27;Could not get input duration, please specify fixed timemarks&#x27;));
            }

            config.timemarks = config.timemarks.map(function(mark) {
              if ((&#x27;&#x27; + mark).match(/^([\d.]+)%$/)) {
                return duration * parseFloat(mark) / 100;
              } else {
                return mark;
              }
            });

            next();
          }
        });
      } else {
        next();
      }
    },

    // Turn all timemarks into numbers and sort them
    function normalizeTimemarks(next) {
      config.timemarks = config.timemarks.map(function(mark) {
        return utils.timemarkToSeconds(mark);
      }).sort(function(a, b) { return a - b; });

      next();
    },

    // Add &#x27;_%i&#x27; to pattern when requesting multiple screenshots and no variable token is present
    function fixPattern(next) {
      var pattern = config.filename || &#x27;tn.png&#x27;;

      if (pattern.indexOf(&#x27;.&#x27;) === -1) {
        pattern += &#x27;.png&#x27;;
      }

      if (config.timemarks.length &#x3e; 1 &#x26;&#x26; !pattern.match(/%(s|0*i)/)) {
        var ext = path.extname(pattern);
        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + &#x27;_%i&#x27; + ext);
      }

      next(null, pattern);
    },

    // Replace filename tokens (%f, %b) in pattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.thumbnails" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.thumbnails">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>thumbnails
        <span class="apidocSignatureSpan">(config, folder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thumbnails = function (config, folder) {
  var self = this;
  var source = this._currentInput.source;
  config = config || { count: 1 };

  // Accept a number of screenshots instead of a config object
  if (typeof config === &#x27;number&#x27;) {
    config = {
      count: config
    };
  }

  // Accept a second &#x27;folder&#x27; parameter instead of config.folder
  if (!(&#x27;folder&#x27; in config)) {
    config.folder = folder || &#x27;.&#x27;;
  }

  // Accept &#x27;timestamps&#x27; instead of &#x27;timemarks&#x27;
  if (&#x27;timestamps&#x27; in config) {
    config.timemarks = config.timestamps;
  }

  // Compute timemarks from count if not present
  if (!(&#x27;timemarks&#x27; in config)) {
    if (!config.count) {
      throw new Error(&#x27;Cannot take screenshots: neither a count nor a timemark list are specified&#x27;);
    }

    var interval = 100 / (1 + config.count);
    config.timemarks = [];
    for (var i = 0; i &#x3c; config.count; i++) {
      config.timemarks.push((interval * (i + 1)) + &#x27;%&#x27;);
    }
  }

  // Parse size option
  if (&#x27;size&#x27; in config) {
    var fixedSize = config.size.match(/^(\d+)x(\d+)$/);
    var fixedWidth = config.size.match(/^(\d+)x\?$/);
    var fixedHeight = config.size.match(/^\?x(\d+)$/);
    var percentSize = config.size.match(/^(\d+)%$/);

    if (!fixedSize &#x26;&#x26; !fixedWidth &#x26;&#x26; !fixedHeight &#x26;&#x26; !percentSize) {
      throw new Error(&#x27;Invalid size parameter: &#x27; + config.size);
    }
  }

  // Metadata helper
  var metadata;
  function getMetadata(cb) {
    if (metadata) {
      cb(null, metadata);
    } else {
      self.ffprobe(function(err, meta) {
        metadata = meta;
        cb(err, meta);
      });
    }
  }

  async.waterfall([
    // Compute percent timemarks if any
    function computeTimemarks(next) {
      if (config.timemarks.some(function(t) { return (&#x27;&#x27; + t).match(/^[\d.]+%$/); })) {
        if (typeof source !== &#x27;string&#x27;) {
          return next(new Error(&#x27;Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks&#x27;));
        }

        getMetadata(function(err, meta) {
          if (err) {
            next(err);
          } else {
            // Select video stream with the highest resolution
            var vstream = meta.streams.reduce(function(biggest, stream) {
              if (stream.codec_type === &#x27;video&#x27; &#x26;&#x26; stream.width * stream.height &#x3e; biggest.width * biggest.height) {
                return stream;
              } else {
                return biggest;
              }
            }, { width: 0, height: 0 });

            if (vstream.width === 0) {
              return next(new Error(&#x27;No video stream in input, cannot take screenshots&#x27;));
            }

            var duration = Number(vstream.duration);
            if (isNaN(duration)) {
              duration = Number(meta.format.duration);
            }

            if (isNaN(duration)) {
              return next(new Error(&#x27;Could not get input duration, please specify fixed timemarks&#x27;));
            }

            config.timemarks = config.timemarks.map(function(mark) {
              if ((&#x27;&#x27; + mark).match(/^([\d.]+)%$/)) {
                return duration * parseFloat(mark) / 100;
              } else {
                return mark;
              }
            });

            next();
          }
        });
      } else {
        next();
      }
    },

    // Turn all timemarks into numbers and sort them
    function normalizeTimemarks(next) {
      config.timemarks = config.timemarks.map(function(mark) {
        return utils.timemarkToSeconds(mark);
      }).sort(function(a, b) { return a - b; });

      next();
    },

    // Add &#x27;_%i&#x27; to pattern when requesting multiple screenshots and no variable token is present
    function fixPattern(next) {
      var pattern = config.filename || &#x27;tn.png&#x27;;

      if (pattern.indexOf(&#x27;.&#x27;) === -1) {
        pattern += &#x27;.png&#x27;;
      }

      if (config.timemarks.length &#x3e; 1 &#x26;&#x26; !pattern.match(/%(s|0*i)/)) {
        var ext = path.extname(pattern);
        pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + &#x27;_%i&#x27; + ext);
      }

      next(null, pattern);
    },

    // Replace filename tokens (%f, %b) in pattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.toFormat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.toFormat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>toFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFormat = function (format) {
  this._currentOutput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.updateFlvMetadata" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.updateFlvMetadata">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>updateFlvMetadata
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateFlvMetadata = function () {
  this._currentOutput.flags.flvmeta = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.usingPreset" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.usingPreset">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>usingPreset
        <span class="apidocSignatureSpan">(preset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">usingPreset = function (preset) {
  if (typeof preset === &#x27;function&#x27;) {
    preset(this);
  } else {
    try {
      var modulePath = path.join(this.options.presets, preset);
      var module = require(modulePath);

      if (typeof module.load === &#x27;function&#x27;) {
        module.load(this);
      } else {
        throw new Error(&#x27;preset &#x27; + modulePath + &#x27; has no load() function&#x27;);
      }
    } catch (err) {
      throw new Error(&#x27;preset &#x27; + modulePath + &#x27; could not be loaded: &#x27; + err.message);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoBitrate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoBitrate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoBitrate
        <span class="apidocSignatureSpan">(bitrate, constant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">videoBitrate = function (bitrate, constant) {
  bitrate = (&#x27;&#x27; + bitrate).replace(/k?$/, &#x27;k&#x27;);

  this._currentOutput.video(&#x27;-b:v&#x27;, bitrate);
  if (constant) {
    this._currentOutput.video(
      &#x27;-maxrate&#x27;, bitrate,
      &#x27;-minrate&#x27;, bitrate,
      &#x27;-bufsize&#x27;, &#x27;3M&#x27;
    );
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*jshint node:true */
&#x27;use strict&#x27;;

exports.load = function(ffmpeg) {
  ffmpeg
    .format(&#x27;avi&#x27;)
    .<span class="apidocCodeKeywordSpan">videoBitrate</span>(&#x27;1024k&#x27;)
    .videoCodec(&#x27;mpeg4&#x27;)
    .size(&#x27;720x?&#x27;)
    .audioBitrate(&#x27;128k&#x27;)
    .audioChannels(2)
    .audioCodec(&#x27;libmp3lame&#x27;)
    .outputOptions([&#x27;-vtag DIVX&#x27;]);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoCodec" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoCodec">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoCodec
        <span class="apidocSignatureSpan">(codec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">videoCodec = function (codec) {
  this._currentOutput.video(&#x27;-vcodec&#x27;, codec);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*jshint node:true */
&#x27;use strict&#x27;;

exports.load = function(ffmpeg) {
  ffmpeg
    .format(&#x27;avi&#x27;)
    .videoBitrate(&#x27;1024k&#x27;)
    .<span class="apidocCodeKeywordSpan">videoCodec</span>(&#x27;mpeg4&#x27;)
    .size(&#x27;720x?&#x27;)
    .audioBitrate(&#x27;128k&#x27;)
    .audioChannels(2)
    .audioCodec(&#x27;libmp3lame&#x27;)
    .outputOptions([&#x27;-vtag DIVX&#x27;]);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoFilter" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoFilter">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoFilter
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">videoFilter = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.videoFilters(utils.makeFilterStrings(filters));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.videoFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>videoFilters
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">videoFilters = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.videoFilters(utils.makeFilterStrings(filters));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Specify custom video filter(s)
*
* Can be called both with one or many filters, or a filter array.
*
* @example
* command.<span class="apidocCodeKeywordSpan">videoFilters</span>(&#x27;filter1&#x27;);
*
* @example
* command.videoFilters(&#x27;filter1&#x27;, &#x27;filter2=param1=value1:param2=value2&#x27;);
*
* @example
* command.videoFilters([&#x27;filter1&#x27;, &#x27;filter2&#x27;]);
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAspect" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAspect">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAspect
        <span class="apidocSignatureSpan">(aspect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAspect = function (aspect) {
  var a = Number(aspect);
  if (isNaN(a)) {
    var match = aspect.match(/^(\d+):(\d+)$/);
    if (match) {
      a = Number(match[1]) / Number(match[2]);
    } else {
      throw new Error(&#x27;Invalid aspect ratio: &#x27; + aspect);
    }
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;aspect&#x27;, a);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAspectRatio" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAspectRatio">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAspectRatio
        <span class="apidocSignatureSpan">(aspect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAspectRatio = function (aspect) {
  var a = Number(aspect);
  if (isNaN(a)) {
    var match = aspect.match(/^(\d+):(\d+)$/);
    if (match) {
      a = Number(match[1]) / Number(match[2]);
    } else {
      throw new Error(&#x27;Invalid aspect ratio: &#x27; + aspect);
    }
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;aspect&#x27;, a);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioBitrate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioBitrate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioBitrate
        <span class="apidocSignatureSpan">(bitrate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioBitrate = function (bitrate) {
  this._currentOutput.audio(&#x27;-b:a&#x27;, (&#x27;&#x27; + bitrate).replace(/k?$/, &#x27;k&#x27;));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioChannels" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioChannels">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioChannels
        <span class="apidocSignatureSpan">(channels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioChannels = function (channels) {
  this._currentOutput.audio(&#x27;-ac&#x27;, channels);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioCodec" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioCodec">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioCodec
        <span class="apidocSignatureSpan">(codec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioCodec = function (codec) {
  this._currentOutput.audio(&#x27;-acodec&#x27;, codec);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFilter" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFilter">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioFilter
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioFilter = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.audioFilters(utils.makeFilterStrings(filters));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioFilters
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioFilters = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.audioFilters(utils.makeFilterStrings(filters));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFrequency" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioFrequency">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioFrequency
        <span class="apidocSignatureSpan">(freq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioFrequency = function (freq) {
  this._currentOutput.audio(&#x27;-ar&#x27;, freq);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioQuality" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAudioQuality">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAudioQuality
        <span class="apidocSignatureSpan">(quality)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAudioQuality = function (quality) {
  this._currentOutput.audio(&#x27;-aq&#x27;, quality);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutoPad" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutoPad">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutoPad
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAutoPad = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutoPadding" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutoPadding">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutoPadding
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAutoPadding = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutopad" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutopad">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutopad
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAutopad = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutopadding" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withAutopadding">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withAutopadding
        <span class="apidocSignatureSpan">(pad, color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withAutopadding = function (pad, color) {
  // Allow autopad(color)
  if (typeof pad === &#x27;string&#x27;) {
    color = pad;
    pad = true;
  }

  // Allow autopad() and autopad(undefined, color)
  if (typeof pad === &#x27;undefined&#x27;) {
    pad = true;
  }

  var filters = createSizeFilters(this._currentOutput, &#x27;pad&#x27;, pad ? color || &#x27;black&#x27; : false);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withDuration" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withDuration">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withDuration
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withDuration = function (duration) {
  this._currentOutput.options(&#x27;-t&#x27;, duration);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPS" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPS">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFPS
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFPS = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPSInput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPSInput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFPSInput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFPSInput = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPSOutput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFPSOutput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFPSOutput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFPSOutput = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFps" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFps">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFps
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFps = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFpsInput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFpsInput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFpsInput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFpsInput = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFpsOutput" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFpsOutput">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFpsOutput
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFpsOutput = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFrames" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withFrames">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withFrames
        <span class="apidocSignatureSpan">(frames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withFrames = function (frames) {
  this._currentOutput.video(&#x27;-vframes&#x27;, frames);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFPS" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFPS">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputFPS
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withInputFPS = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFormat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFormat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withInputFormat = function (format) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFps" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputFps">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputFps
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withInputFps = function (fps) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withInputOption = function (options) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentInput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withInputOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withInputOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withInputOptions = function (options) {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentInput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNativeFramerate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNativeFramerate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withNativeFramerate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withNativeFramerate = function () {
  if (!this._currentInput) {
    throw new Error(&#x27;No input specified&#x27;);
  }

  this._currentInput.options(&#x27;-re&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNoAudio" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNoAudio">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withNoAudio
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withNoAudio = function () {
  this._currentOutput.audio.clear();
  this._currentOutput.audioFilters.clear();
  this._currentOutput.audio(&#x27;-an&#x27;);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNoVideo" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withNoVideo">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withNoVideo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withNoVideo = function () {
  this._currentOutput.video.clear();
  this._currentOutput.videoFilters.clear();
  this._currentOutput.video(&#x27;-vn&#x27;);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOption = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOptions = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFPS" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFPS">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputFPS
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOutputFPS = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFormat" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFormat">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOutputFormat = function (format) {
  this._currentOutput.options(&#x27;-f&#x27;, format);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFps" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputFps">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputFps
        <span class="apidocSignatureSpan">(fps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOutputFps = function (fps) {
  this._currentOutput.video(&#x27;-r&#x27;, fps);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputOption" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputOption">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputOption
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOutputOption = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputOptions" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withOutputOptions">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withOutputOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withOutputOptions = function (options) {
  var doSplit = true;

  if (arguments.length &#x3e; 1) {
    options = [].slice.call(arguments);
    doSplit = false;
  }

  if (!Array.isArray(options)) {
    options = [options];
  }

  this._currentOutput.options(options.reduce(function(options, option) {
    var split = String(option).split(&#x27; &#x27;);

    if (doSplit &#x26;&#x26; split.length === 2) {
      options.push(split[0], split[1]);
    } else {
      options.push(option);
    }

    return options;
  }, []));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withSize" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withSize">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withSize
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withSize = function (size) {
  var filters = createSizeFilters(this._currentOutput, &#x27;size&#x27;, size);

  this._currentOutput.sizeFilters.clear();
  this._currentOutput.sizeFilters(filters);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoBitrate" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoBitrate">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoBitrate
        <span class="apidocSignatureSpan">(bitrate, constant)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withVideoBitrate = function (bitrate, constant) {
  bitrate = (&#x27;&#x27; + bitrate).replace(/k?$/, &#x27;k&#x27;);

  this._currentOutput.video(&#x27;-b:v&#x27;, bitrate);
  if (constant) {
    this._currentOutput.video(
      &#x27;-maxrate&#x27;, bitrate,
      &#x27;-minrate&#x27;, bitrate,
      &#x27;-bufsize&#x27;, &#x27;3M&#x27;
    );
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoCodec" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoCodec">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoCodec
        <span class="apidocSignatureSpan">(codec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withVideoCodec = function (codec) {
  this._currentOutput.video(&#x27;-vcodec&#x27;, codec);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoFilter" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoFilter">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoFilter
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withVideoFilter = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.videoFilters(utils.makeFilterStrings(filters));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoFilters" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.withVideoFilters">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>withVideoFilters
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withVideoFilters = function (filters) {
  if (arguments.length &#x3e; 1) {
    filters = [].slice.call(arguments);
  }

  if (!Array.isArray(filters)) {
    filters = [filters];
  }

  this._currentOutput.videoFilters(utils.makeFilterStrings(filters));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.writeToStream" id="apidoc.element.fluent-ffmpeg.fluent_ffmpeg.prototype.writeToStream">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.fluent_ffmpeg.prototype.</span>writeToStream
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeToStream = function (stream, options) {
  if (stream &#x26;&#x26; !(&#x27;writable&#x27; in stream)) {
    options = stream;
    stream = undefined;
  }

  if (!stream) {
    if (process.version.match(/v0\.8\./)) {
      throw new Error(&#x27;PassThrough stream is not supported on node v0.8&#x27;);
    }

    stream = new PassThrough();
  }

  this.output(stream, options).run();
  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.jsdoc_aliases" id="apidoc.module.fluent-ffmpeg.jsdoc_aliases">module fluent-ffmpeg.jsdoc_aliases</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.jsdoc_aliases.defineTags" id="apidoc.element.fluent-ffmpeg.jsdoc_aliases.defineTags">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.jsdoc_aliases.</span>defineTags
        <span class="apidocSignatureSpan">(dict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineTags = function (dict) {
	dict.defineTag(&#x27;aliases&#x27;, {
		onTagged: function(doclet, tag) {
			doclet.aliases = tag.text.split(&#x27;,&#x27;);
		}
	});

	dict.defineTag(&#x27;category&#x27;, {
		onTagged: function(doclet, tag) {
			doclet.category = tag.text;
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.podcast" id="apidoc.module.fluent-ffmpeg.podcast">module fluent-ffmpeg.podcast</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.podcast.load" id="apidoc.element.fluent-ffmpeg.podcast.load">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.podcast.</span>load
        <span class="apidocSignatureSpan">(ffmpeg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (ffmpeg) {
  ffmpeg
    .format(&#x27;m4v&#x27;)
    .videoBitrate(&#x27;512k&#x27;)
    .videoCodec(&#x27;libx264&#x27;)
    .size(&#x27;320x176&#x27;)
    .audioBitrate(&#x27;128k&#x27;)
    .audioCodec(&#x27;aac&#x27;)
    .audioChannels(1)
    .outputOptions([&#x27;-flags&#x27;, &#x27;+loop&#x27;, &#x27;-cmp&#x27;, &#x27;+chroma&#x27;, &#x27;-partitions&#x27;,&#x27;+parti4x4+partp8x8+partb8x8&#x27;, &#x27;-flags2&#x27;,
      &#x27;+mixed_refs&#x27;, &#x27;-me_method umh&#x27;, &#x27;-subq 5&#x27;, &#x27;-bufsize 2M&#x27;, &#x27;-rc_eq \&#x27;blurCplx^(1-qComp)\&#x27;&#x27;,
      &#x27;-qcomp 0.6&#x27;, &#x27;-qmin 10&#x27;, &#x27;-qmax 51&#x27;, &#x27;-qdiff 4&#x27;, &#x27;-level 13&#x27; ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  preset(this);
} else {
  try {
    var modulePath = path.join(this.options.presets, preset);
    var module = require(modulePath);

    if (typeof module.load === &#x27;function&#x27;) {
      module.<span class="apidocCodeKeywordSpan">load</span>(this);
    } else {
      throw new Error(&#x27;preset &#x27; + modulePath + &#x27; has no load() function&#x27;);
    }
  } catch (err) {
    throw new Error(&#x27;preset &#x27; + modulePath + &#x27; could not be loaded: &#x27; + err.message);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fluent-ffmpeg.utils" id="apidoc.module.fluent-ffmpeg.utils">module fluent-ffmpeg.utils</a></h1>


    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.args" id="apidoc.element.fluent-ffmpeg.utils.args">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>args
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">args = function () {
  var list = [];

  // Append argument(s) to the list
  var argfunc = function() {
    if (arguments.length === 1 &#x26;&#x26; Array.isArray(arguments[0])) {
      list = list.concat(arguments[0]);
    } else {
      list = list.concat([].slice.call(arguments));
    }
  };

  // Clear argument list
  argfunc.clear = function() {
    list = [];
  };

  // Return argument list
  argfunc.get = function() {
    return list;
  };

  // Find argument &#x27;arg&#x27; in list, and if found, return an array of the &#x27;count&#x27; items that follow it
  argfunc.find = function(arg, count) {
    var index = list.indexOf(arg);
    if (index !== -1) {
      return list.slice(index + 1, index + 1 + (count || 0));
    }
  };

  // Find argument &#x27;arg&#x27; in list, and if found, remove it as well as the &#x27;count&#x27; items that follow it
  argfunc.remove = function(arg, count) {
    var index = list.indexOf(arg);
    if (index !== -1) {
      list.splice(index, (count || 0) + 1);
    }
  };

  // Clone argument list
  argfunc.clone = function() {
    var cloned = utils.args();
    cloned(list);
    return cloned;
  };

  return argfunc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (index !== -1) {
      list.splice(index, (count || 0) + 1);
    }
  };

  // Clone argument list
  argfunc.clone = function() {
    var cloned = utils.<span class="apidocCodeKeywordSpan">args</span>();
    cloned(list);
    return cloned;
  };

  return argfunc;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.copy" id="apidoc.element.fluent-ffmpeg.utils.copy">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>copy
        <span class="apidocSignatureSpan">(source, dest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (source, dest) {
  Object.keys(source).forEach(function(key) {
    dest[key] = source[key];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          encoders = encoders ? encoders[1].trim().split(&#x27; &#x27;) : [];

          var decoders = codecData.description.match(ffDecodersRegexp);
          decoders = decoders ? decoders[1].trim().split(&#x27; &#x27;) : [];

          if (encoders.length || decoders.length) {
var coderData = {};
utils.<span class="apidocCodeKeywordSpan">copy</span>(codecData, coderData);
delete coderData.canEncode;
delete coderData.canDecode;

encoders.forEach(function(name) {
  data[name] = {};
  utils.copy(coderData, data[name]);
  data[name].canEncode = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.extractCodecData" id="apidoc.element.fluent-ffmpeg.utils.extractCodecData">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractCodecData
        <span class="apidocSignatureSpan">(command, stderrLine, codecsObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractCodecData = function (command, stderrLine, codecsObject) {
  var inputPattern = /Input #[0-9]+, ([^ ]+),/;
  var durPattern = /Duration\: ([^,]+)/;
  var audioPattern = /Audio\: (.*)/;
  var videoPattern = /Video\: (.*)/;

  if (!(&#x27;inputStack&#x27; in codecsObject)) {
    codecsObject.inputStack = [];
    codecsObject.inputIndex = -1;
    codecsObject.inInput = false;
  }

  var inputStack = codecsObject.inputStack;
  var inputIndex = codecsObject.inputIndex;
  var inInput = codecsObject.inInput;

  var format, dur, audio, video;

  if (format = stderrLine.match(inputPattern)) {
    inInput = codecsObject.inInput = true;
    inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;

    inputStack[inputIndex] = { format: format[1], audio: &#x27;&#x27;, video: &#x27;&#x27;, duration: &#x27;&#x27; };
  } else if (inInput &#x26;&#x26; (dur = stderrLine.match(durPattern))) {
    inputStack[inputIndex].duration = dur[1];
  } else if (inInput &#x26;&#x26; (audio = stderrLine.match(audioPattern))) {
    audio = audio[1].split(&#x27;, &#x27;);
    inputStack[inputIndex].audio = audio[0];
    inputStack[inputIndex].audio_details = audio;
  } else if (inInput &#x26;&#x26; (video = stderrLine.match(videoPattern))) {
    video = video[1].split(&#x27;, &#x27;);
    inputStack[inputIndex].video = video[0];
    inputStack[inputIndex].video_details = video;
  } else if (/Output #\d+/.test(stderrLine)) {
    inInput = codecsObject.inInput = false;
  } else if (/Stream mapping:|Press (\[q\]|ctrl-c) to stop/.test(stderrLine)) {
    command.emit.apply(command, [&#x27;codecData&#x27;].concat(inputStack));
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// &#x27;codecData&#x27; event
if (self.listeners(&#x27;codecData&#x27;).length) {
  var codecDataSent = false;
  var codecObject = {};

  stderrRing.callback(function(line) {
    if (!codecDataSent)
      codecDataSent = utils.<span class="apidocCodeKeywordSpan">extractCodecData</span>(self, line, codecObject);
  });
}

// &#x27;progress&#x27; event
if (self.listeners(&#x27;progress&#x27;).length) {
  stderrRing.callback(function(line) {
    utils.extractProgress(self, line);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.extractError" id="apidoc.element.fluent-ffmpeg.utils.extractError">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractError
        <span class="apidocSignatureSpan">(stderr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractError = function (stderr) {
  // Only return the last stderr lines that don&#x27;t start with a space or a square bracket
  return stderr.split(nlRegexp).reduce(function(messages, message) {
    if (message.charAt(0) === &#x27; &#x27; || message.charAt(0) === &#x27;[&#x27;) {
      return [];
    } else {
      messages.push(message);
      return messages;
    }
  }, []).join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        function endCB(err, stdoutRing, stderrRing) {
delete self.ffmpegProc;

if (err) {
  if (err.message.match(/ffmpeg exited with code/)) {
    // Add ffmpeg error message
    err.message += &#x27;: &#x27; + utils.<span class="apidocCodeKeywordSpan">extractError</span>(stderrRing.get());
  }

  emitEnd(err, stdoutRing.get(), stderrRing.get());
} else {
  // Find out which outputs need flv metadata
  var flvmeta = self._outputs.filter(function(output) {
    return output.flags.flvmeta;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.extractProgress" id="apidoc.element.fluent-ffmpeg.utils.extractProgress">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>extractProgress
        <span class="apidocSignatureSpan">(command, stderrLine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractProgress = function (command, stderrLine) {
  var progress = parseProgressLine(stderrLine);

  if (progress) {
    // build progress report object
    var ret = {
      frames: parseInt(progress.frame, 10),
      currentFps: parseInt(progress.fps, 10),
      currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace(&#x27;kbits/s&#x27;, &#x27;&#x27;)) : 0,
      targetSize: parseInt(progress.size || progress.Lsize, 10),
      timemark: progress.time
    };

    // calculate percent progress using duration
    if (command._ffprobeData &#x26;&#x26; command._ffprobeData.format &#x26;&#x26; command._ffprobeData.format.duration) {
      var duration = Number(command._ffprobeData.format.duration);
      if (!isNaN(duration))
        ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;
    }
    command.emit(&#x27;progress&#x27;, ret);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          codecDataSent = utils.extractCodecData(self, line, codecObject);
      });
    }

    // &#x27;progress&#x27; event
    if (self.listeners(&#x27;progress&#x27;).length) {
      stderrRing.callback(function(line) {
        utils.<span class="apidocCodeKeywordSpan">extractProgress</span>(self, line);
      });
    }
  }
},

function endCB(err, stdoutRing, stderrRing) {
  delete self.ffmpegProc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.linesRing" id="apidoc.element.fluent-ffmpeg.utils.linesRing">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>linesRing
        <span class="apidocSignatureSpan">(maxLines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linesRing = function (maxLines) {
  var cbs = [];
  var lines = [];
  var current = null;
  var closed = false
  var max = maxLines - 1;

  function emit(line) {
    cbs.forEach(function(cb) { cb(line); });
  }

  return {
    callback: function(cb) {
      lines.forEach(function(l) { cb(l); });
      cbs.push(cb);
    },

    append: function(str) {
      if (closed) return;
      if (str instanceof Buffer) str = &#x27;&#x27; + str;
      if (!str || str.length === 0) return;

      var newLines = str.split(nlRegexp);

      if (newLines.length === 1) {
        if (current !== null) {
          current = current + newLines.shift();
        } else {
          current = newLines.shift();
        }
      } else {
        if (current !== null) {
          current = current + newLines.shift();
          emit(current);
          lines.push(current);
        }

        current = newLines.pop();

        newLines.forEach(function(l) {
          emit(l);
          lines.push(l);
        });

        if (max &#x3e; -1 &#x26;&#x26; lines.length &#x3e; max) {
          lines.splice(0, lines.length - max);
        }
      }
    },

    get: function() {
      if (current !== null) {
        return lines.concat([current]).join(&#x27;\n&#x27;);
      } else {
        return lines.join(&#x27;\n&#x27;);
      }
    },

    close: function() {
      if (closed) return;

      if (current !== null) {
        emit(current);
        lines.push(current);

        if (max &#x3e; -1 &#x26;&#x26; lines.length &#x3e; max) {
          lines.shift();
        }

        current = null;
      }

      closed = true;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Apply niceness
if (options.niceness &#x26;&#x26; options.niceness !== 0 &#x26;&#x26; !utils.isWindows) {
  args.unshift(&#x27;-n&#x27;, options.niceness, command);
  command = &#x27;nice&#x27;;
}

var stdoutRing = utils.<span class="apidocCodeKeywordSpan">linesRing</span>(maxLines);
var stdoutClosed = false;

var stderrRing = utils.linesRing(maxLines);
var stderrClosed = false;

// Spawn process
var ffmpegProc = spawn(command, args, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.makeFilterStrings" id="apidoc.element.fluent-ffmpeg.utils.makeFilterStrings">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>makeFilterStrings
        <span class="apidocSignatureSpan">(filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFilterStrings = function (filters) {
  return filters.map(function(filterSpec) {
    if (typeof filterSpec === &#x27;string&#x27;) {
      return filterSpec;
    }

    var filterString = &#x27;&#x27;;

    // Filter string format is:
    // [input1][input2]...filter[output1][output2]...
    // The &#x27;filter&#x27; part can optionaly have arguments:
    //   filter=arg1:arg2:arg3
    //   filter=arg1=v1:arg2=v2:arg3=v3

    // Add inputs
    if (Array.isArray(filterSpec.inputs)) {
      filterString += filterSpec.inputs.map(function(streamSpec) {
        return streamSpec.replace(streamRegexp, &#x27;[$1]&#x27;);
      }).join(&#x27;&#x27;);
    } else if (typeof filterSpec.inputs === &#x27;string&#x27;) {
      filterString += filterSpec.inputs.replace(streamRegexp, &#x27;[$1]&#x27;);
    }

    // Add filter
    filterString += filterSpec.filter;

    // Add options
    if (filterSpec.options) {
      if (typeof filterSpec.options === &#x27;string&#x27; || typeof filterSpec.options === &#x27;number&#x27;) {
        // Option string
        filterString += &#x27;=&#x27; + filterSpec.options;
      } else if (Array.isArray(filterSpec.options)) {
        // Option array (unnamed options)
        filterString += &#x27;=&#x27; + filterSpec.options.map(function(option) {
          if (typeof option === &#x27;string&#x27; &#x26;&#x26; option.match(filterEscapeRegexp)) {
            return &#x27;\&#x27;&#x27; + option + &#x27;\&#x27;&#x27;;
          } else {
            return option;
          }
        }).join(&#x27;:&#x27;);
      } else if (Object.keys(filterSpec.options).length) {
        // Option object (named options)
        filterString += &#x27;=&#x27; + Object.keys(filterSpec.options).map(function(option) {
          var value = filterSpec.options[option];

          if (typeof value === &#x27;string&#x27; &#x26;&#x26; value.match(filterEscapeRegexp)) {
            value = &#x27;\&#x27;&#x27; + value + &#x27;\&#x27;&#x27;;
          }

          return option + &#x27;=&#x27; + value;
        }).join(&#x27;:&#x27;);
      }
    }

    // Add outputs
    if (Array.isArray(filterSpec.outputs)) {
      filterString += filterSpec.outputs.map(function(streamSpec) {
        return streamSpec.replace(streamRegexp, &#x27;[$1]&#x27;);
      }).join(&#x27;&#x27;);
    } else if (typeof filterSpec.outputs === &#x27;string&#x27;) {
      filterString += filterSpec.outputs.replace(streamRegexp, &#x27;[$1]&#x27;);
    }

    return filterString;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fileOutput ? [&#x27;-y&#x27;] : [],

        // Complex filters
        complexFilters,

        // Outputs, filters and output options
        this._outputs.reduce(function(args, output) {
var sizeFilters = utils.<span class="apidocCodeKeywordSpan">makeFilterStrings</span>(output.sizeFilters.get());
var audioFilters = output.audioFilters.get();
var videoFilters = output.videoFilters.get().concat(sizeFilters);
var outputArg;

if (!output.target) {
  outputArg = [];
} else if (typeof output.target === &#x27;string&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.timemarkToSeconds" id="apidoc.element.fluent-ffmpeg.utils.timemarkToSeconds">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>timemarkToSeconds
        <span class="apidocSignatureSpan">(timemark)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timemarkToSeconds = function (timemark) {
  if (typeof timemark === &#x27;number&#x27;) {
    return timemark;
  }

  if (timemark.indexOf(&#x27;:&#x27;) === -1 &#x26;&#x26; timemark.indexOf(&#x27;.&#x27;) &#x3e;= 0) {
    return Number(timemark);
  }

  var parts = timemark.split(&#x27;:&#x27;);

  // add seconds
  var secs = Number(parts.pop());

  if (parts.length) {
    // add minutes
    secs += Number(parts.pop()) * 60;
  }

  if (parts.length) {
    // add hours
    secs += Number(parts.pop()) * 3600;
  }

  return secs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    next();
  }
},

// Turn all timemarks into numbers and sort them
function normalizeTimemarks(next) {
  config.timemarks = config.timemarks.map(function(mark) {
    return utils.<span class="apidocCodeKeywordSpan">timemarkToSeconds</span>(mark);
  }).sort(function(a, b) { return a - b; });

  next();
},

// Add &#x27;_%i&#x27; to pattern when requesting multiple screenshots and no variable token is present
function fixPattern(next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fluent-ffmpeg.utils.which" id="apidoc.element.fluent-ffmpeg.utils.which">
        function <span class="apidocSignatureSpan">fluent-ffmpeg.utils.</span>which
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">which = function (name, callback) {
  if (name in whichCache) {
    return callback(null, whichCache[name]);
  }

  which(name, function(err, result){
    if (err) {
      // Treat errors as not found
      return callback(null, whichCache[name] = &#x27;&#x27;);
    }
    callback(null, whichCache[name] = result);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // Search in the PATH
  function(ffmpeg, cb) {
    if (ffmpeg.length) {
      return cb(null, ffmpeg);
    }

    utils.<span class="apidocCodeKeywordSpan">which</span>(&#x27;ffmpeg&#x27;, function(err, ffmpeg) {
      cb(err, ffmpeg);
    });
  }
], function(err, ffmpeg) {
  if (err) {
    callback(err);
  } else {
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
